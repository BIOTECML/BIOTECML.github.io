<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MachineLearning - 18&nbsp; Análisis cluster</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./170_MDSmodels.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos coincidentes",
    "search-copy-link-title": "Copiar enlace para buscar",
    "search-hide-matches-text": "Ocultar coincidencias adicionales",
    "search-more-match-text": "más coincidencia en este documento",
    "search-more-matches-text": "más coincidencias en este documento",
    "search-clear-button-title": "Limpiar",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Entregar"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Análisis cluster</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MachineLearning</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Prefacio</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./01_IntroCourse.html" class="sidebar-item-text sidebar-link">Parte 1. Introducción</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_introAD.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción al análisis de datos</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_introAA.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción al Aprendizaje Automático (AA)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./30_RandRstudio.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introducción a R y RStudio</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./40_DataBases.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Bases de datos</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./02_FirstStepsAA.html" class="sidebar-item-text sidebar-link">Parte 2. Primeros pasos</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./50_AED.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introducción al análisis de datos</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./03_SupervisedAA.html" class="sidebar-item-text sidebar-link">Parte 3. Aprendizaje supervisado</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./60_RegressionModels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Modelos de Regresión</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./70_LogisticModels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Modelos de Regresión Logística</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./80_SurvivalModels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Modelos de supervivencia</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./90_BayesianClassif.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Modelos de clasificación Naïve Bayes</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./100_kNNmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Modelo de los k vecinos más cercanos (kNN)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./110_SVMmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Máquinas de Vector Soporte (SVM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./120_DTmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Árboles de decisiónn (DT)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./130_Ensemblemodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Modelos de conjunto (Ensemble models)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./140_Boostingmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Modelos Boosting</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./04_NonSupervisedAA.html" class="sidebar-item-text sidebar-link">Parte 4. Aprendizaje no supervisado</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./150_Discriminantmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Análisis discriminante (AD)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./160_PrinCompmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Componentes principales (CP)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./170_MDSmodels.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Métodos de escalado multidimensional (MDS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./180_Clustermodels.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Análisis cluster</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">Referencias</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#sec-180.1" id="toc-sec-180.1" class="nav-link active" data-scroll-target="#sec-180.1"><span class="toc-section-number">18.1</span>  Definición de métricas</a>
  <ul>
  <li><a href="#sec-180.1.1" id="toc-sec-180.1.1" class="nav-link" data-scroll-target="#sec-180.1.1"><span class="toc-section-number">18.1.1</span>  Distancia</a>
  <ul class="collapse">
  <li><a href="#tipos-de-distancias" id="toc-tipos-de-distancias" class="nav-link" data-scroll-target="#tipos-de-distancias"><span class="toc-section-number">18.1.1.1</span>  Tipos de distancias</a></li>
  <li><a href="#tipos-de-similitudes" id="toc-tipos-de-similitudes" class="nav-link" data-scroll-target="#tipos-de-similitudes"><span class="toc-section-number">18.1.1.2</span>  Tipos de similitudes</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-180.2" id="toc-sec-180.2" class="nav-link" data-scroll-target="#sec-180.2"><span class="toc-section-number">18.2</span>  Modelos de agrupación jerárquica</a>
  <ul>
  <li><a href="#sec-180.2.1" id="toc-sec-180.2.1" class="nav-link" data-scroll-target="#sec-180.2.1"><span class="toc-section-number">18.2.1</span>  Distancias entre grupos</a></li>
  <li><a href="#sec-180.2.2" id="toc-sec-180.2.2" class="nav-link" data-scroll-target="#sec-180.2.2"><span class="toc-section-number">18.2.2</span>  Análisis de la agrupación</a>
  <ul class="collapse">
  <li><a href="#métodos-gráficos" id="toc-métodos-gráficos" class="nav-link" data-scroll-target="#métodos-gráficos"><span class="toc-section-number">18.2.2.1</span>  Métodos gráficos</a></li>
  <li><a href="#métodos-numéricos" id="toc-métodos-numéricos" class="nav-link" data-scroll-target="#métodos-numéricos"><span class="toc-section-number">18.2.2.2</span>  Métodos numéricos</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-180.3" id="toc-sec-180.3" class="nav-link" data-scroll-target="#sec-180.3"><span class="toc-section-number">18.3</span>  Modelos de agrupación partitivos</a>
  <ul>
  <li><a href="#sec-180.3.1" id="toc-sec-180.3.1" class="nav-link" data-scroll-target="#sec-180.3.1"><span class="toc-section-number">18.3.1</span>  Algoritmo de k-medias</a></li>
  <li><a href="#sec-180.3.2" id="toc-sec-180.3.2" class="nav-link" data-scroll-target="#sec-180.3.2"><span class="toc-section-number">18.3.2</span>  Minibatch k-medias</a></li>
  <li><a href="#sec-180.3.3" id="toc-sec-180.3.3" class="nav-link" data-scroll-target="#sec-180.3.3"><span class="toc-section-number">18.3.3</span>  Algoritmo DBSCAN</a></li>
  <li><a href="#análisis-de-la-agrupación" id="toc-análisis-de-la-agrupación" class="nav-link" data-scroll-target="#análisis-de-la-agrupación"><span class="toc-section-number">18.3.4</span>  Análisis de la agrupación</a></li>
  </ul></li>
  <li><a href="#sec-180.4" id="toc-sec-180.4" class="nav-link" data-scroll-target="#sec-180.4"><span class="toc-section-number">18.4</span>  Análisis cluster en <code>R</code></a>
  <ul>
  <li><a href="#sec-180.4.1" id="toc-sec-180.4.1" class="nav-link" data-scroll-target="#sec-180.4.1"><span class="toc-section-number">18.4.1</span>  Bancos de datos</a>
  <ul class="collapse">
  <li><a href="#gene-expression-leukemia" id="toc-gene-expression-leukemia" class="nav-link" data-scroll-target="#gene-expression-leukemia"><span class="toc-section-number">18.4.1.1</span>  Gene expression leukemia</a></li>
  <li><a href="#vehicle-silhouettes" id="toc-vehicle-silhouettes" class="nav-link" data-scroll-target="#vehicle-silhouettes"><span class="toc-section-number">18.4.1.2</span>  Vehicle silhouettes</a></li>
  <li><a href="#sales" id="toc-sales" class="nav-link" data-scroll-target="#sales"><span class="toc-section-number">18.4.1.3</span>  Sales</a></li>
  </ul></li>
  <li><a href="#sec-180.4.2" id="toc-sec-180.4.2" class="nav-link" data-scroll-target="#sec-180.4.2"><span class="toc-section-number">18.4.2</span>  Modelos de agrupación</a>
  <ul class="collapse">
  <li><a href="#gene-expression-leukemia-1" id="toc-gene-expression-leukemia-1" class="nav-link" data-scroll-target="#gene-expression-leukemia-1"><span class="toc-section-number">18.4.2.1</span>  Gene expression leukemia</a></li>
  <li><a href="#vehicle-silhouettes-1" id="toc-vehicle-silhouettes-1" class="nav-link" data-scroll-target="#vehicle-silhouettes-1"><span class="toc-section-number">18.4.2.2</span>  Vehicle silhouettes</a></li>
  <li><a href="#sales-1" id="toc-sales-1" class="nav-link" data-scroll-target="#sales-1"><span class="toc-section-number">18.4.2.3</span>  Sales</a></li>
  </ul></li>
  <li><a href="#sec-180.4.3" id="toc-sec-180.4.3" class="nav-link" data-scroll-target="#sec-180.4.3"><span class="toc-section-number">18.4.3</span>  Modelos de agrupación con CP</a>
  <ul class="collapse">
  <li><a href="#gene-expression-leukemia-2" id="toc-gene-expression-leukemia-2" class="nav-link" data-scroll-target="#gene-expression-leukemia-2"><span class="toc-section-number">18.4.3.1</span>  Gene expression leukemia</a></li>
  <li><a href="#vehicle-silhouettes-2" id="toc-vehicle-silhouettes-2" class="nav-link" data-scroll-target="#vehicle-silhouettes-2"><span class="toc-section-number">18.4.3.2</span>  Vehicle silhouettes</a></li>
  <li><a href="#sales-2" id="toc-sales-2" class="nav-link" data-scroll-target="#sales-2"><span class="toc-section-number">18.4.3.3</span>  Sales</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-180.5" id="toc-sec-180.5" class="nav-link" data-scroll-target="#sec-180.5"><span class="toc-section-number">18.5</span>  Ejercicios</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-180" class="quarto-section-identifier d-none d-lg-block"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Análisis cluster</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Los modelos de agrupación o <em>cluster</em> hacen referencia a un amplio abanico de algoritmos cuya finalidad es encontrar patrones o grupos (<em>clusters</em>) dentro de un conjunto de muestras. Las particiones se establecen de forma que, las observaciones que están dentro de un mismo grupo, son similares entre ellas y distintas a las observaciones de otros grupos. Se trata de un método de aprendizaje no supervisado, ya que el proceso no tiene en cuenta a qué grupo pertenece realmente cada observación (si es que existe tal información). Esta característica es la que diferencia al <em>clustering</em> de los métodos de clasificación en los que se emplea la verdadera clasificación durante su entrenamiento.</p>
<p>Dada la utilidad del <em>clustering</em> en disciplinas muy distintas (genómica, marketing…), se han desarrollado multitud de variantes y adaptaciones de sus métodos y algoritmos. Podemos distinguir tres grupos:</p>
<ul>
<li><p><em>Agrupación jerárquica</em>: este tipo de algoritmos no requieren que el usuario especifique de antemano el número de grupos.</p></li>
<li><p><em>Agrupación partitiva</em>: este tipo de algoritmos requieren que el usuario especifique de antemano el número de <em>clusters</em> que se van a crear.</p></li>
<li><p><em>Métodos combinados</em>: algoritmos que combinan los dos grupos anteriores.</p></li>
</ul>
<p>Todos los modelos de agrupación se basan en el establecimiento de una métrica de divergencia o similitud entre las muestras, a partir de la información contenida en las características de las predictoras consideradas, que es utilizada para construir las agrupaciones. Todo algoritmo de agrupación se organiza en cuatro etapas:</p>
<ul>
<li>Identificación del tipo de características (numéricas, categóricas, o lógicas)</li>
<li>Elección de la métrica entre muestras.</li>
<li>Elección del modelo de agrupación.</li>
<li>Validación de los resultados.</li>
</ul>
<p>Para facilitar la comprensión de los algoritmos, y dado que es lo más habitual, consideramos únicamente situaciones donde todas las características son de tipo numérico. De hecho, en muchas situaciones los modelos de agrupación se utilizan como complemento a otras técnicas de aprendizaje automático. Es muy habitual que con las puntuaciones obtenidas mediante un análisis de componentes principales o escalado multidimensional se proceda con un modelo de agrupación para establecer patrones de comportamiento.</p>
<p>En este tema veremos diferentes situaciones relacionadas con estos procedimientos.</p>
<section id="sec-180.1" class="level2" data-number="18.1">
<h2 data-number="18.1" class="anchored" data-anchor-id="sec-180.1"><span class="header-section-number">18.1</span> Definición de métricas</h2>
<p>Para proceder con cualquier proceso de agrupación es necesario establecer el concepto de métrica (divergencia o similitud) para un conjunto de muestras sobre las que se ha medido un conjunto de <span class="math inline">\(k\)</span> características. El uso de un tipo de métrica u otro dependerá del tipo de características medidas sobre las muestras. En primer lugar definimos los conceptos de distancia y/o similitud y posteriormente veremos los tipos más habituales.</p>
<section id="sec-180.1.1" class="level3" data-number="18.1.1">
<h3 data-number="18.1.1" class="anchored" data-anchor-id="sec-180.1.1"><span class="header-section-number">18.1.1</span> Distancia</h3>
<p>Una función <span class="math inline">\(d\)</span> se denomina distancia si para tres muestras <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span> se verifica que:</p>
<ul>
<li><span class="math inline">\(d(x,y) \geq 0\)</span></li>
<li><span class="math inline">\(d(x,y) = 0 \Leftrightarrow x=y\)</span></li>
<li><span class="math inline">\(d(x,y)=d(y,x)\)</span></li>
<li><span class="math inline">\(d(x,z) \leq d(x,y) + d(y,z)\)</span></li>
</ul>
<p>Las métricas de distancia se utilizan principalmente para medir la cercanía o lejanía entre muestras que se han medido sobre características de tipo numérico.</p>
<section id="tipos-de-distancias" class="level4" data-number="18.1.1.1">
<h4 data-number="18.1.1.1" class="anchored" data-anchor-id="tipos-de-distancias"><span class="header-section-number">18.1.1.1</span> Tipos de distancias</h4>
<p>A continuación se presentan las medidas de distancia más habituales. En adelante consideramos dos muestras <span class="math inline">\(x=(x_1,...,x_k)\)</span> e <span class="math inline">\(y=(y_1,...,y_k)\)</span> medidas sobre <span class="math inline">\(k\)</span> características.</p>
<p><strong>Distancia euclídea o distancia l2.</strong> La distancia euclídea entre dos muestras se define como la longitud del segmento que une ambos puntos, es decir,</p>
<p><span class="math display">\[d(x,y) = \sqrt{\sum_{i=1}^k (x_i-y_i)^2}\]</span></p>
<p><strong>Distancia de Minkowski.</strong> La distancia de Minkowski de orden <span class="math inline">\(q\)</span> se define como</p>
<p><span class="math display">\[d(x,y) = \left(\sum_{i=1}^k |x_i-y_i|^q\right)^{1/q}\]</span></p>
<p><strong>Distancia de Manhattan (ciudad) o distancia l1.</strong> La distancia de Manhattan se define como</p>
<p><span class="math display">\[d(x,y) = \sum_{i=1}^k |x_i-y_i|\]</span></p>
<p><strong>Distancia de Tchebychev.</strong> La distancia de Tchebychev se define como</p>
<p><span class="math display">\[d(x,y) = \underset{i}{max} |x_i-y_i|\]</span></p>
<p><strong>Distancia de Mahalanobis.</strong> La distancia de Mahalanobis se define como</p>
<p><span class="math display">\[d(x,y) = \sqrt{(x-y)^t S^{-1}(x-y)}, \]</span> con <span class="math inline">\(S\)</span> la matriz de varianzas-covarianzas entre <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>.</p>
<p><strong>Distancia correlación.</strong> Se define la distancia correlación, a partir de la correlación entre <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> (<span class="math inline">\(\rho_{xy}\)</span>), como</p>
<p><span class="math display">\[d(x,y)=1-\rho_{xy}\]</span> ### Similitud {#sec-180.1.2}</p>
<p>Una función <span class="math inline">\(s\)</span> se denomina similitud si para tres muestras <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span> y un valor real finito arbitrario <span class="math inline">\(s_0\)</span> se verifica que:</p>
<ul>
<li><span class="math inline">\(s(x,y) \leq s_0\)</span></li>
<li><span class="math inline">\(s(x,x) = s_0\)</span></li>
<li><span class="math inline">\(s(x,y) = s(y,x)\)</span></li>
</ul>
</section>
<section id="tipos-de-similitudes" class="level4" data-number="18.1.1.2">
<h4 data-number="18.1.1.2" class="anchored" data-anchor-id="tipos-de-similitudes"><span class="header-section-number">18.1.1.2</span> Tipos de similitudes</h4>
<p>Las métricas de similitud se utilizan principalmente para establecer la cercanía o lejanía entre muestras que se han medido sobre características de tipo binario codificadas como 0-1. Dadas dos muestras de este tipo tenemos la tabla de asociación:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">x</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">a+b</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">c+d</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Total</td>
<td style="text-align: center;">a+c</td>
<td style="text-align: center;">b+d</td>
<td style="text-align: center;">t=a+b+c+d</td>
</tr>
</tbody>
</table>
<p><strong>Coeficiente de adecuación simple (<em>simple matching coefficient</em>).</strong> El coeficiente de adecuación simple se define como</p>
<p><span class="math display">\[SMC = \frac{a+d}{m}\]</span></p>
<p><strong>Índice de Jaccard.</strong> El índice de Jaccard se define como</p>
<p><span class="math display">\[J=\frac{a}{c+b+a}\]</span></p>
</section>
</section>
</section>
<section id="sec-180.2" class="level2" data-number="18.2">
<h2 data-number="18.2" class="anchored" data-anchor-id="sec-180.2"><span class="header-section-number">18.2</span> Modelos de agrupación jerárquica</h2>
<p>Este procedimiento intenta identificar grupos relativamente homogéneos de casos (o de variables) basándose en las características seleccionadas, mediante un algoritmo que comienza con cada caso (o cada variable) en un <em>cluster</em> diferente y combina los <em>clusters</em> hasta que sólo queda uno. Es posible analizar las variables brutas pero en el caso de variables de tipo numérico se suelen estandarizar.</p>
<p>Los pasos a seguir con este algoritmo son:</p>
<ol type="1">
<li>Elegir distancia o similitud entre muestras y la elección del modelo de agrupación o distancia entre los diferentes <em>clusters</em> que se van formando.</li>
<li>Calcular la distancia o similitud elegida entre cada par de muestras.</li>
<li>Comenzar el proceso de agrupación utilizando el modelo de agrupación o de distancia entre grupos prefijado hasta que todas las muestras se encuentren en un único grupo o <em>cluster</em>.</li>
</ol>
<p>En primer lugar se presentan los procesos de agrupación de <em>clusters</em> más habituales.</p>
<section id="sec-180.2.1" class="level3" data-number="18.2.1">
<h3 data-number="18.2.1" class="anchored" data-anchor-id="sec-180.2.1"><span class="header-section-number">18.2.1</span> Distancias entre grupos</h3>
<p>Aunque existe una gran variedad de definiciones de distancia entre grupos, aquí se presentan los más habituales. En adelante consideramos <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> dos grupos o <em>clusters</em>.</p>
<p><strong>Vecino más cercano (<em>Single linkage</em>):</strong> se calcula la distancia entre todos los posibles pares formados por una observación del <em>cluster</em> A y una del <em>cluster</em> B. La menor de todas ellas se selecciona como la distancia entre los dos <em>clusters</em>. Se trata de la medida menos conservadora (<em>minimal intercluster dissimilarity</em>). Tenemos entonces que:</p>
<p><span class="math display">\[d(A,B) = \underset{i\in A;j\in B}{min} d(i,j)\]</span></p>
<p>Este modelo proporciona <em>clusters</em> más alargados.</p>
<p><strong>Vecino más lejano (<em>Complete linkage</em>):</strong> se calcula la distancia entre todos los posibles pares formados por una observación del <em>cluster</em> A y una del <em>cluster</em> B. La menor de todas ellas se selecciona como la distancia entre los dos <em>clusters</em>. Se trata de la medida menos conservadora (<em>minimal intercluster dissimilarity</em>). Tenemos entonces que:</p>
<p><span class="math display">\[d(A,B) = \underset{i\in A;j\in B}{max} d(i,j)\]</span></p>
<p>Este modelo proporciona <em>clusters</em> más esféricos.</p>
<p><strong>Promedio de grupo (<em>Average linkage</em>):</strong> se calcula la distancia entre todos los posibles pares formados por una observación del <em>cluster</em> A y una del <em>cluster</em> B. El valor promedio de todas ellas se selecciona como la distancia entre los dos <em>clusters</em> (<em>mean intercluster dissimilarity</em>). Si <span class="math inline">\(n_A\)</span> y <span class="math inline">\(n_B\)</span> son el número de muestras en los <em>clusters</em> <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> respectivamente, tenemos que:</p>
<p><span class="math display">\[d(A,B) = \frac{1}{n_a n_b}\sum_{i\in A;j\in B} d(i,j)\]</span></p>
<p>Este modelo proporciona <em>clusters</em> más robustos.</p>
<p><strong>Centroide (<em>Centroid linkage</em>):</strong> se calcula el centroide de cada uno de los <em>clusters</em> y se selecciona la distancia entre ellos como la distancia entre los dos <em>clusters</em>. Si <span class="math inline">\(\bar{x}_A\)</span> y <span class="math inline">\(\bar{x}_B\)</span> son el vector promedio de las muestras en los <em>clusters</em> <span class="math inline">\(A\)</span> y <span class="math inline">\(B\)</span> respectivamente, tenemos que:</p>
<p><span class="math display">\[d(A,B) = d(\bar{x}_A,\bar{x}_B)\]</span></p>
<p>Este modelo proporciona <em>clusters</em> más robustos.</p>
<p><strong>Ward (<em>Ward linkage</em>):</strong> se trata de un método general. La selección del par de <em>clusters</em> que se combinan en cada paso del <em>agglomerative hierarchical clustering</em> se basa en el valor óptimo de una función objetivo, pudiendo ser esta última cualquier función definida por el analista. El método <em>Ward’s minimum variance</em> es un caso particular en el que el objetivo es minimizar la suma total de varianza intracluster. En cada paso, se identifican aquellos 2 <em>clusters</em> cuya fusión conlleva menor incremento de la varianza total intracluster.</p>
</section>
<section id="sec-180.2.2" class="level3" data-number="18.2.2">
<h3 data-number="18.2.2" class="anchored" data-anchor-id="sec-180.2.2"><span class="header-section-number">18.2.2</span> Análisis de la agrupación</h3>
<p>En un modelo de <em>cluster</em> jerárquico se pueden llegar a soluciones muy diferentes debido a la elección de la distancia entre pares de muestras y la distancia entre grupos. Para analizar las posibles soluciones existen diferentes herramientas gráficas y númericas que pasamos a analizar.</p>
<section id="métodos-gráficos" class="level4" data-number="18.2.2.1">
<h4 data-number="18.2.2.1" class="anchored" data-anchor-id="métodos-gráficos"><span class="header-section-number">18.2.2.1</span> Métodos gráficos</h4>
<p>Los métodos gráficos habituales son el <code>dendograma</code> y el <code>scree plot</code>.</p>
<section id="dendograma" class="level5">
<h5 class="anchored" data-anchor-id="dendograma">Dendograma</h5>
<p>El dendograma (o árbol invertido) es un diagrama de árbol que se utiliza para representar de forma gráfica la estructura de los grupos que se forman al aplicar un algoritmo de agrupamiento jerárquico y sus niveles de similitud. Cuanto más próximos más similares serán. Se puede representar de forma ascendente o descendente, pero siempre contiene la misma información.</p>
<p>Su estructura consiste en un conjunto de ramas que se extienden desde un eje vertical y se ramifican hacia arriba. Los objetos se representan en las hojas de las ramas y los grupos en los nodos interiores de estas. La longitud de las ramas se utiliza para representar la distancia o similitud entre los objetos o grupos que conectan.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://raw.githubusercontent.com/ia4legos/MachineLearning/main/images/dendograma.png" width="450" height="450" class="figure-img"></p>
</figure>
</div>
<p>En el dendograma observamos la agrupación de los mamíferos según la dieta que siguen. Como hemos comentado anteriormente no indicamos a priori el número de grupos que se deben crear, por lo que dependerá del valor que escojamos.</p>
<p>Los grupos se representan mediante líneas horizontales y las alturas representan distancias, de manera que la altura a la que se unen dos grupos es la distancia entre ellos. Por ejemplo, foca y delfín (<em>seal</em> y <em>dolphin</em>) son diferentes del resto, formando un grupo propio que no se ha unido al resto de animales hasta el último paso. Si cortamos con una línea horizontal a la altura 20, podemos observar que se forman tres grupos muy claros.</p>
</section>
<section id="gráfico-scree" class="level5">
<h5 class="anchored" data-anchor-id="gráfico-scree">Gráfico scree</h5>
<p>El gráfico scree se utiliza habitualmente para determinar el número de <em>clusters</em> óptimo mediante la representación de la distancia de agrupación versus el número de <em>clusters</em> considerados. Se considera que el número óptimo de <em>clusters</em> se alcanza cuando la curva obtenida se estabiliza sobre cierto valor. Sin embargo, este procedimiento resulta muy costoso computacionalmente si el número de muestras con el que trabajamos es muy alto.</p>
<p>Podemos utilizar versiones de este gráfico con los criterios numéricos que vemos a continuación prefijando el número máximo de grupos a considerar.</p>
</section>
</section>
<section id="métodos-numéricos" class="level4" data-number="18.2.2.2">
<h4 data-number="18.2.2.2" class="anchored" data-anchor-id="métodos-numéricos"><span class="header-section-number">18.2.2.2</span> Métodos numéricos</h4>
<p>Como se analizó anteriormente, las tareas no supervisadas no tienen datos reales con los que comparar en la evaluación del modelo. Sin embargo, aún podemos medir la calidad de las asignaciones de conglomerados cuantificando qué tan estrechamente están relacionados los objetos dentro del mismo conglomerado (cohesión de conglomerados), así como qué tan distintos son los diferentes conglomerados entre sí (separación de conglomerados).</p>
<p>Dos medidas comunes son la medida de suma interna de cuadrados o suma de cuadrado intra grupos (WSS) y el coeficiente de silueta. WSS calcula la suma de diferencias al cuadrado entre observaciones y centroides, que es una cuantificación de la cohesión de los conglomerados (los valores más pequeños indican que los conglomerados son más compactos). El coeficiente de silueta cuantifica qué tan bien pertenece cada punto a su grupo asignado en comparación con los grupos vecinos, donde las puntuaciones más cercanas a 1 indican que están bien agrupados y las puntuaciones más cercanas a -1 indican que están mal agrupados.</p>
</section>
</section>
</section>
<section id="sec-180.3" class="level2" data-number="18.3">
<h2 data-number="18.3" class="anchored" data-anchor-id="sec-180.3"><span class="header-section-number">18.3</span> Modelos de agrupación partitivos</h2>
<p>Los algoritmos partitivos se diferencian principalmente de los modelos jerárquicos en que a priori se debe establecer el número de grupos (k) que se desean obtener. En muchas aplicaciones prácticas estos algoritmos de agrupación se utilizan como los modelos supervisados de clasificación.</p>
<p>Para comenzar con este tipo de algoritmos necesitamos especificar los centroides que califican los k centroides iniciales. Un centroide es un punto que identifica a un <em>cluster</em> o grupo. Generalmente, se trata de un conjunto de puntos, en el que cada uno representa a un grupo de los que se han formado. Los resultados finales que se obtengan dependerán de la forma en la que se seleccionen inicialmente estos centroides.</p>
<p>Lo más usual es elegir un conjunto aleatorio de k puntos y asignarlos como centroides y cada paso que avance el algoritmo irá mejorando la precisión. La elección de estos puede afectar al rendimiento del algoritmo pero nunca afectará a su convergencia. A continuación presentamos los modelos partitivos más habituales.</p>
<section id="sec-180.3.1" class="level3" data-number="18.3.1">
<h3 data-number="18.3.1" class="anchored" data-anchor-id="sec-180.3.1"><span class="header-section-number">18.3.1</span> Algoritmo de k-medias</h3>
<p>El algoritmo K-Means o K-Medias propuesto por Lloyd pretende partir un conjunto de <code>N</code> registros u observaciones en <code>k</code> grupos, de forma que su distancia al centroide de cada grupo sea mínima (o la similitud con respecto al centroide sea máxima). Los pasos del algoritmo son:</p>
<ul>
<li>Paso 1. Se seleccionan aleatoriamente <code>k</code> centroides (<span class="math inline">\(C_i, i = 1,...,k\)</span>).</li>
<li>Paso 2. Se asigna cada uno de los restantes <code>N</code> puntos al centroide <span class="math inline">\(C_i\)</span> más cercano, utilizando como criterio que un punto es asignado al grupo <span class="math inline">\(i\)</span> si la distancia al cuadrado del cada punto al centroide <span class="math inline">\(C_i\)</span> es la menor de todas las obtenidas con respecto al resto de centroides.</li>
<li>Paso 3. Recalcular los centroides a partir de los puntos asignados en cada uno de los grupos o cluster.</li>
<li>Paso 4. Repetir los puntos 2 y 3 hasta que los grupos no cambien o se supere una tolerancia de usuario o un número máximo de iteraciones.</li>
</ul>
<p>Podemos ver el funcionamiento del algoritmo mediante la imagen siguiente:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://dcain.etsin.upm.es/~carlos/bookAA/_images/Kmedias-esquema.png" width="550" height="475" class="figure-img"></p>
</figure>
</div>
<p>La principal dificultad con este algoritmo es el establecimiento del número de clusters. Por ese motivo se suele usar en conjunto de datos conde tenemos un target categórico que nos indica el número de grupos que debemos considerar.</p>
</section>
<section id="sec-180.3.2" class="level3" data-number="18.3.2">
<h3 data-number="18.3.2" class="anchored" data-anchor-id="sec-180.3.2"><span class="header-section-number">18.3.2</span> Minibatch k-medias</h3>
<p>El algoritmo de agrupación en <em>clusters</em> <em>minibatch k-means</em> es una versión del algoritmo estándar de k-medias que se puede usar en sustitución de este cuando se tratan grandes conjuntos de datos. Con el objetivo de reducir la dificultad computacional utiliza lotes o conjuntos de datos pequeños, aleatorios y de tamaño fijo para almacenarlos en la memoria y luego, con cada iteración, se recopila una muestra aleatoria de los datos y se usa para actualizar los <em>clusters</em>. A la vez que usa mini-lotes para reducir el tiempo de cálculo, intenta optimizar la función objetivo.</p>
</section>
<section id="sec-180.3.3" class="level3" data-number="18.3.3">
<h3 data-number="18.3.3" class="anchored" data-anchor-id="sec-180.3.3"><span class="header-section-number">18.3.3</span> Algoritmo DBSCAN</h3>
<p>Este es un algoritmo que se utiliza para identificar grupos (también conocidos como regiones densas), en los que no requiere que el usuario especifique el número de grupos a priori. Los grupos de puntos se asignan donde hay altas densidades y se calcula qué tan cercanos deben ser los puntos para que se consideren un miembro del grupo.</p>
<p>Para identificar los grupos de una base de datos usando DBSCAN, el algoritmo realiza los siguientes pasos:</p>
<ol type="1">
<li>Selecciona un punto al azar del conjunto de datos y recupera todos los puntos dentro de una distancia <code>Epsilon</code> desde ese punto.</li>
<li>Si el número de puntos recuperados en el paso 1 es mayor o igual a <code>MinPts</code>, marca todos estos puntos como pertenecientes al mismo grupo y repite el proceso con la finalidad de identificar puntos adicionales que pertenecen al grupo.</li>
<li>Si por el contrario, el número de puntos recuperados en el paso 1 es inferior a <code>MinPts</code>, el punto se marca como ruido.</li>
<li>Repite los pasos 1, 2 y 3 hasta que se hayan procesado todos los puntos del conjunto de datos.</li>
</ol>
<p>Las instancias principales son aquellas que se encuentran en regiones densas. Todas las que estén en la vecindad de una instancia principal pertenecen al mismo grupo. Cualquier instancia que no sea una instancia central y no tenga una en su vecindad se considera una anomalía.</p>
<p>El algoritmo funciona bien si todos los <em>clusters</em> son lo suficientemente densos y si están bien separados por regiones de baja densidad. Es particularmente útil para encontrar grupos de forma arbitraria en grandes conjuntos de datos y es capaz de identificar grupos incluso en presencia de ruido o valores atípicos. Sin embargo, no es determinista y es sensible a la elección de <code>Epsilon</code> y <code>MinPts</code>. Estos parámetros deben elegirse cuidadosamente para obtener buenos resultados.</p>
<p>De esta forma el algoritmo DBSCAN permite identificar tres tipos de puntos:</p>
<ul>
<li>Punto núcleo (<em>Core point</em>): es aquel en el que al menos tiene minPts número de puntos (incluido el propio punto) en su región circundante dentro del radio eps.</li>
<li>Punto frontera (<em>Border point</em>): es aquel en el que es alcanzable desde un punto núcleo y hay menos de minPts número de puntos dentro de su región circundante.</li>
<li>Valor atípico (<em>Outlier</em>): no es un punto central ni es accesible desde ningún punto central.</li>
</ul>
<p>En la imagen siguiente se muestra el funcionamiento del algoritmo para dos grupos y con minPts igual a cuatro.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://dcain.etsin.upm.es/~carlos/bookAA/_images/dbscan.png" width="350" height="350" class="figure-img"></p>
</figure>
</div>
</section>
<section id="análisis-de-la-agrupación" class="level3" data-number="18.3.4">
<h3 data-number="18.3.4" class="anchored" data-anchor-id="análisis-de-la-agrupación"><span class="header-section-number">18.3.4</span> Análisis de la agrupación</h3>
<p>En todos los algoritmos partitivos el análisis de la agrupación obtenida se realiza con los mismos criterios que para los clusters jerárquicos.</p>
</section>
</section>
<section id="sec-180.4" class="level2" data-number="18.4">
<h2 data-number="18.4" class="anchored" data-anchor-id="sec-180.4"><span class="header-section-number">18.4</span> Análisis cluster en <code>R</code></h2>
<p>Para llevar a cabo el análisis cluster vamos a utilizar diferentes modelos de aprendizaje que están definidos en <code>mlr3</code>. Son los más habituales pero hay muchos más definidos que pueden ser explorados en toro momento. Todos ellos se encuentran dentro de las librerías que hemos visto y en la <code>mlr3cluster</code> que cargaremos en este caso. En concreto nos centramos en los modelos:</p>
<ul>
<li><p><code>clust.hclust</code> para cluster jerárquicos, cuyos parámetros principales son <code>method</code> para establecer el método de agrupación de los clusters, y <code>distmethod</code> para definir el tipo de distancia entre las muestras. Se pueden consultar las opciones disponibles en este <a href="https://mlr3cluster.mlr-org.com/reference/mlr_learners_clust.hclust.html">enlace</a>.</p></li>
<li><p><code>clust.kmeans</code> para el algoritmo de k-medias cuyos parámetros principales son <code>centers</code> que establece el número de clusters, <code>iter.max</code> que fija el número de iteraciones del método, y <code>algorithm</code> que establece el algoritmo utilizado en el proceso iterativo. Se pueden consultar las opciones disponibles en este <a href="https://mlr3cluster.mlr-org.com/reference/mlr_learners_clust.kmeans.html">enlace</a>.</p></li>
<li><p><code>clust.MBatchKMeans</code> para el algoritmo minibatch k-means, cuyos parámetros principales son <code>clusters</code> para identificar el número de clusters considerados, <code>batch_size</code> para fijar el tamaño de cada uno de los batch, y <code>max_iters</code> que fija el número máximo de iteraciones del algoritmo. Este modelo utiliza la función <code>MiniBatchKmeans()</code> que se encuentra alojada en la librería <code>ClusterR</code>. Se pueden consultar las opciones disponibles en este <a href="https://mlr3cluster.mlr-org.com/reference/mlr_learners_clust.MiniBatchKMeans.html">enlace</a>.</p></li>
<li><p><code>clust.dbscan</code> para el método dbscan, cuyos parámetros principales son <code>eps</code> para la tolerancia, y <code>minPts</code> para definir el número de puntos. Este modelo utiliza la función <code>dbscan()</code> que se encuentra alojada en la librería <code>dbscan</code>. Se pueden consultar las opciones disponibles en este <a href="https://mlr3cluster.mlr-org.com/reference/mlr_learners_clust.dbscan.html">enlace</a>.</p></li>
</ul>
<p>A continuación cargamos todas las librerías necesarias para los análisis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Paquetes anteriores</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">library</span>(sjPlot)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="fu">library</span>(knitr) <span class="co"># para formatos de tablas</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="fu">library</span>(skimr)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="fu">library</span>(DataExplorer)</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="fu">library</span>(GGally)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="fu">library</span>(ggpubr)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="fu">library</span>(cvms)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="fu">library</span>(kknn)</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="fu">library</span>(rpart.plot)</span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="fu">library</span>(rda)</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="fu">library</span>(klaR)</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="fu">library</span>(ggord)</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="fu">theme_set</span>(<span class="fu">theme_sjplot2</span>())</span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co"># Paquetes AA</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="fu">library</span>(mlr3verse)</span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="fu">library</span>(mlr3tuning)</span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="fu">library</span>(mlr3tuningspaces)</span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="fu">library</span>(mlr3cluster)</span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="fu">library</span>(cluster)</span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="fu">library</span>(ClusterR)</span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="fu">library</span>(dbscan)</span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="fu">library</span>(gbm)</span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="fu">library</span>(RWeka)</span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="fu">library</span>(xgboost)</span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="fu">library</span>(lightgbm)</span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="fu">library</span>(FactoMineR)</span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="fu">library</span>(factoextra)</span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="fu">library</span>(rsvd)</span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="fu">library</span>(kernlab)</span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="fu">library</span>(fastICA)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="sec-180.4.1" class="level3" data-number="18.4.1">
<h3 data-number="18.4.1" class="anchored" data-anchor-id="sec-180.4.1"><span class="header-section-number">18.4.1</span> Bancos de datos</h3>
<p>Para ejemplificar el uso de los modelos de cluster vamos a utilizar tres bancos de datos: <code>Gene expression leukemia</code>, <code>Vehicle silhouettes</code>, y <code>Sales</code>. Mostramos el uso de los modelos como herramienta individual y más tarde como acompañamiento de un modelo de componentes principales. A continuación presentamos los tres bancos de datos y la definición de la tarea de agrupación cada uno de ellos.</p>
<section id="gene-expression-leukemia" class="level4" data-number="18.4.1.1">
<h4 data-number="18.4.1.1" class="anchored" data-anchor-id="gene-expression-leukemia"><span class="header-section-number">18.4.1.1</span> Gene expression leukemia</h4>
<p>Este banco de datos lo hemos descrito en temas anteriores. Cargamos los datos, y generamos la tarea dejando fuera la característica que identifica el tipo de tumor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Leemos los datos</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>geneexpleu <span class="ot">=</span> <span class="fu">read_rds</span>(<span class="st">"geneexpressionleukemia.rds"</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># Eliminamos el indicador de la muestra</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>geneexpleu <span class="ot">=</span> geneexpleu <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>samples)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># Consideramos matriz de características y tipos</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>X_genes <span class="ot">=</span> geneexpleu <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>type)</span>
<span id="cb2-7"><a href="#cb2-7"></a>y_genes <span class="ot">=</span> geneexpleu[,<span class="st">"type"</span>]</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co"># Debemos cambiar los nombres pq no se respeta la convención de R ya que todas ellas empiezan por un número</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="fu">names</span>(X_genes) <span class="ot">=</span> <span class="fu">str_replace_all</span>(<span class="fu">names</span>(X_genes),<span class="st">"[/_-]"</span>,<span class="st">""</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="fu">names</span>(X_genes) <span class="ot">=</span> <span class="fu">paste</span>(<span class="st">"V"</span>, <span class="fu">names</span>(X_genes), <span class="at">sep=</span><span class="st">"_"</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co"># Definimos la tarea de cluster </span></span>
<span id="cb2-12"><a href="#cb2-12"></a>tsk_genes <span class="ot">=</span> <span class="fu">as_task_clust</span>(X_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="vehicle-silhouettes" class="level4" data-number="18.4.1.2">
<h4 data-number="18.4.1.2" class="anchored" data-anchor-id="vehicle-silhouettes"><span class="header-section-number">18.4.1.2</span> Vehicle silhouettes</h4>
<p>Este conjunto de datos recoge información de cuatro tipos diferentes de vehículos, utilizando un conjunto de características extraídas de su silueta. Para el experimento se utilizaron cuatro vehículos modelo “Corgie”: un bus de dos pisos, una camioneta Cheverolet, un Saab 9000 y un Opel Manta 400. El objetivo del estudio es clasificar una silueta dada como uno de cuatro tipos diferentes de vehículos. Todos los atributos son numéricos discretos salvo la última variable que registra el tipo de vehículo. No existen valores perdidos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Leemos los datos</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>vehicle <span class="ot">=</span> <span class="fu">read_rds</span>(<span class="st">"vehicle.rds"</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"># Consideramos matriz de características y tipos</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>X_vehicle <span class="ot">=</span> vehicle <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>Class)</span>
<span id="cb3-5"><a href="#cb3-5"></a>y_vehicle <span class="ot">=</span> vehicle[,<span class="st">"Class"</span>]</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co"># Definimos la tarea de cluster cambiando los nombres</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>tsk_vehicle <span class="ot">=</span> <span class="fu">as_task_clust</span>(X_vehicle)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sales" class="level4" data-number="18.4.1.3">
<h4 data-number="18.4.1.3" class="anchored" data-anchor-id="sales"><span class="header-section-number">18.4.1.3</span> Sales</h4>
<p>Contiene las cantidades compradas semanalmente de 800 productos a lo largo de 52 semanas. Todos los atributos son numéricos sin valores perdidos y van identificados mediante W(número de la semana). En este caso no tenemos posible variable target.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># Leemos los datos</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>sales <span class="ot">=</span> <span class="fu">read_rds</span>(<span class="st">"sales.rds"</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"># Eliminamos la variable que identifica el código del producto y la almacenamos por si hiciera falta</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>X_sales <span class="ot">=</span> sales <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>Product_Code)</span>
<span id="cb4-5"><a href="#cb4-5"></a>y_sales <span class="ot">=</span> sales[,<span class="st">"Product_Code"</span>]</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co"># Definimos la tarea de cluster </span></span>
<span id="cb4-7"><a href="#cb4-7"></a>tsk_sales <span class="ot">=</span> <span class="fu">as_task_clust</span>(X_sales)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="sec-180.4.2" class="level3" data-number="18.4.2">
<h3 data-number="18.4.2" class="anchored" data-anchor-id="sec-180.4.2"><span class="header-section-number">18.4.2</span> Modelos de agrupación</h3>
<p>En primer lugar comenzamos presentando los modelos de agrupación puros, es decir a partir de la variables originales, y en el punto siguiente veremos que ocurre cuando utilizamos los modelos de cluster como resultado del preprocesado mediante componentes principales. Cuando sea posible compararemos la solución del cluster con el target establecido en la base de datos.</p>
<section id="gene-expression-leukemia-1" class="level4" data-number="18.4.2.1">
<h4 data-number="18.4.2.1" class="anchored" data-anchor-id="gene-expression-leukemia-1"><span class="header-section-number">18.4.2.1</span> Gene expression leukemia</h4>
<section id="modelo-de-agrupación-jerárquica" class="level5">
<h5 class="anchored" data-anchor-id="modelo-de-agrupación-jerárquica">Modelo de agrupación jerárquica</h5>
<p>Comenzamos con el análisis de cluster jerárquico utilizando el método de <code>Ward</code> que proporciona buenas soluciones en muchas situaciones prácticas, y la distancia euclídea. En este caso consideramos todos los datos para el análisis. En primer lugar establecemos el modelo de aprendizaje, y lo entrenamos con todos los datos disponibles. Esto nos permitirá realizar los gráficos por defecto para estos modelos de aprendizaje con la función <code>autoplot</code>. En la tarea de preprocesamiento únicamente escalamos las variables para reducir la variabilidad original.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Preprocesamiento</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb5-3"><a href="#cb5-3"></a>   <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">TRUE</span>))</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb5-6"><a href="#cb5-6"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.1256943 </code></pre>
</div>
</div>
<p>El valor del score es muy bajo indicando que el modelo establecido no parce muy adecuado. Obtenemos el dendograma y el gráfico scree asociado con el modelo obtenido.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>modelo <span class="ot">=</span> genes_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-006-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>En el dendograma obtenido se aprecian muchos grupos pero poco homogéneos. De hecho no queda muy clara cual sería la solución más correcta. Vamos a representar sobre el dendograma la solución con 5 grupos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="fu">rect.hclust</span>(modelo, <span class="at">k =</span> <span class="dv">5</span>, <span class="at">border =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-007-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>Una vez fijada una solución el siguiente paso es la caracterización de los clusters obtenidos a partir de las características consideradas para su construcción. Sin embargo, cuando el número de características es muy elevado resulta imposible dicha tarea. Por ese motivo se recurre a un análisis de reducción de la dimensión antes del análisis cluster, ya que entonces si resulta posible caracterizar los clusters obtenidos.</p>
<p>Otra opción como en este caso es comparar la solución cluster con el target original y analizar la matriz de confusión, para entender como se agrupan las muestras y si los grupos se corresponden con la información original. En este caso tomamos la solución con cinco clusters (ya que el target tenía cinco tipos de tumor) y comparamos los resultados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">5</span>)</span>
<span id="cb9-3"><a href="#cb9-3"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="fu">table</span>(y_genes<span class="sc">$</span>type, pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                  
                    1  2  3  4  5
  AML               2 16  0  8  0
  Bone_Marrow       0  0 10  0  0
  Bone_Marrow_CD34  7  1  0  0  0
  PB                0  0  0  0 10
  PBSC_CD34        10  0  0  0  0</code></pre>
</div>
</div>
<p>Podemos ver como los clusters 2 a 4 se caracterizan por contener sujetos con un tipo de leucemia específica, mientras que el cluster es una combinación de varios de ellos. Podríamos establecer la equivalencia:</p>
<ul>
<li>Cluster 1: PBSC_CD34</li>
<li>Cluster 2: AML</li>
<li>Cluster 3: Bone_Marrow</li>
<li>Cluster 4: AML</li>
<li>Cluster 5: PB</li>
</ul>
<p>No queda claro donde agregar el tipo Bone_Marrow_CD34, y aparecen dos grupos con tumores AML mayoritariamente. No parece que la solución obtenida permita clasificar adecuadamente los tipos de tumor, y queda claro que el tipo AML es el más difícil de aislar de forma independiente.</p>
</section>
<section id="modelo-de-k-medias" class="level5">
<h5 class="anchored" data-anchor-id="modelo-de-k-medias">Modelo de k-medias</h5>
<p>Utilizamos ahora el algoritmo de k-medias fijando k igual a 5, el número de grupos que deseamos encontrar, para que coincida con el número de niveles del target. Definimos el modelo de aprendizaje, utilizando el mismo preprocesado que con el algoritmo anterior:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.kmeans"</span>, <span class="at">centers =</span>  <span class="dv">5</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos analizar la solución obtenida identificando el cluster al que es asignado cada elemento de la muestra y comparando lo resultados con los datos originales.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># Asignación del modelo</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>genes_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>cluster</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 3 3 3 3 3 3 1 3 3 3 3 3 3 3 3 3 3 3 2 4 3 1 1 1 3 4 1 1 3 3 2 1 1 1 3 1 1 1
[39] 4 2 4 1 1 2 5 5 5 5 5 5 5 5 5 5 2 2 2 2 2 2 2 2 2 2</code></pre>
</div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># Tamaño de cada uno de los grupos</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>genes_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>size</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 14 14 22  4 10</code></pre>
</div>
</div>
<p>Veamos ahora como se corresponde la clasificación del algoritmo con los valores originales:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="fu">table</span>(y_genes<span class="sc">$</span>type, genes_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>cluster)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                  
                    1  2  3  4  5
  AML              13  4  5  4  0
  Bone_Marrow       0  0 10  0  0
  Bone_Marrow_CD34  1  0  7  0  0
  PB                0  0  0  0 10
  PBSC_CD34         0 10  0  0  0</code></pre>
</div>
</div>
<p>El modelo se comporta de forma similar la jerárquico, incluso empeora la asignación a los grupos. Para verificar el mal comportamiento podemos valorar los scores asociados a este modelo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># Predicción para cada modelo</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="co"># Valores de scores</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.1994495 </code></pre>
</div>
</div>
<p>El resultado obtenido mejora los del modelo jerárquico a pesar de que la clasificación obtenida es menos clara. En este caso tenemos dos posibilidades de mejora. La primera consiste en determinar el número óptimo de grupos a considerar mediante una búsqueda automática, mientras que la segunda pasa por realizar el algoritmo de k-medias después del preprocesado mediante componentes principales. Esta segunda la exploraremos un poco más adelante en este mismo tema.</p>
</section>
</section>
<section id="vehicle-silhouettes-1" class="level4" data-number="18.4.2.2">
<h4 data-number="18.4.2.2" class="anchored" data-anchor-id="vehicle-silhouettes-1"><span class="header-section-number">18.4.2.2</span> Vehicle silhouettes</h4>
<p>Realizamos ahora el análisis para el banco de datos de vehículos.</p>
<section id="modelo-de-agrupación-jerárquica-1" class="level5">
<h5 class="anchored" data-anchor-id="modelo-de-agrupación-jerárquica-1">Modelo de agrupación jerárquica</h5>
<p>De nuevo utilizamos el método de Ward para obtener la solución jerárquica. De nuevo escalamos los valores de las características</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># Preprocesamiento</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>pp_vehicle <span class="ot">=</span>  </span>
<span id="cb20-3"><a href="#cb20-3"></a>   <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">TRUE</span>))</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb20-6"><a href="#cb20-6"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)</span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb20-11"><a href="#cb20-11"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_vehicle)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
        0.641126 </code></pre>
</div>
</div>
<p>El score es bastante alto mostrando que el modelo de cluster obtenido parece bastante adecuado. Veamos el dendograma correspondiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>modelo <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-014-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>Parecen apreciarse claramente una solución con tres grupos, pero para poder realizar las comparaciones necesarias con el target original, optamos por una solución con cuatro grupos que representamos gráficamente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="fu">rect.hclust</span>(modelo, <span class="at">k =</span> <span class="dv">4</span>, <span class="at">border =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-015-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>A la vista del dendograma una solución con 4 grupos parece bastante buena para definir grupos homogéneos. Comparamos la solución del modelo con el target original.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">4</span>)</span>
<span id="cb24-3"><a href="#cb24-3"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="fu">table</span>(y_vehicle, pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         
y_vehicle   1   2   3   4
     bus   93  25  58  42
     opel  41  78  53  40
     saab  40  75  59  43
     van  112   0  81   6</code></pre>
</div>
</div>
<p>La solución obtenida es bastante mala porque no resulta posible identificar cada grupo con un tipo de vehículo ya que los datos están muy repartidos. Esto puede ser debido a que las variables no poseen suficiente información para clasificar las observaciones o que las utilizarlas directamente las distancia obtenidas no nos permiten realizar agrupaciones adecuadas. Como en el ejemplo anterior un preprocesado mediante CP podría resolver en parte este problema. Veamos que ocurre si utilizamos el algoritmo de k-medias.</p>
</section>
<section id="modelo-de-k-medias-1" class="level5">
<h5 class="anchored" data-anchor-id="modelo-de-k-medias-1">Modelo de k-medias</h5>
<p>Utilizamos ahora el algoritmo de k-medias fijando k igual a 4.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.kmeans"</span>, <span class="at">centers =</span>  <span class="dv">4</span>)</span>
<span id="cb26-3"><a href="#cb26-3"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Identificamos clusters y comparamos los resultados con los datos originales.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># Asignación del modelo</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>vehicle_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>cluster</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  [1] 2 2 1 2 3 1 2 2 2 2 2 2 2 2 2 1 4 2 1 1 4 4 2 2 1 2 4 1 1 4 2 2 2 1 2 2 4
 [38] 3 1 4 1 4 4 2 1 4 4 4 4 2 4 2 1 2 1 2 2 4 1 4 1 4 4 4 2 4 4 1 2 1 1 1 2 4
 [75] 2 1 2 4 1 4 4 1 2 4 2 1 2 4 2 4 1 2 1 2 4 1 4 4 1 4 3 2 2 4 1 1 1 4 4 1 2
[112] 2 4 4 4 2 1 1 4 2 4 4 2 4 4 4 4 4 2 1 1 2 2 4 1 3 4 2 4 2 2 4 1 4 2 1 2 2
[149] 2 2 1 2 2 1 2 1 2 4 2 2 4 1 2 2 1 1 2 1 4 4 1 1 2 1 2 2 2 2 2 4 1 4 2 4 1
[186] 2 2 2 1 2 1 2 2 1 2 4 1 4 4 4 2 2 1 1 2 2 2 4 4 1 2 2 2 1 4 2 4 1 4 2 1 4
[223] 1 4 4 2 1 2 1 4 4 4 4 1 2 4 2 4 1 4 2 2 4 1 4 4 2 2 1 4 4 1 4 2 2 1 2 2 1
[260] 1 4 2 2 2 1 4 4 2 2 4 4 2 2 2 1 2 4 4 1 2 2 4 4 1 4 2 2 4 1 4 2 3 2 2 1 2
[297] 1 4 2 2 1 2 2 2 4 2 1 1 1 1 1 4 2 1 4 4 4 2 4 1 1 1 4 1 2 4 1 2 2 2 2 1 1
[334] 4 1 1 4 1 2 2 2 4 4 1 1 1 1 2 2 2 1 4 2 4 1 2 2 1 2 1 1 1 2 2 4 1 4 4 4 2
[371] 2 2 2 2 4 1 1 4 4 1 4 1 4 1 2 4 2 4 3 1 4 2 2 2 1 2 1 2 2 2 1 2 1 2 1 2 4
[408] 4 2 2 2 4 4 2 4 1 2 2 4 2 4 1 2 4 2 2 1 2 1 2 1 1 4 4 1 2 4 4 2 1 1 4 2 1
[445] 1 4 1 1 1 2 2 2 2 2 1 4 4 2 1 2 2 1 2 4 1 4 4 1 1 2 4 1 1 1 4 1 1 4 2 4 1
[482] 1 2 2 4 4 1 2 4 1 1 2 4 1 1 2 1 4 4 1 1 1 4 4 1 1 1 2 2 1 4 2 1 2 4 4 2 1
[519] 4 2 2 4 2 3 1 2 1 1 2 4 2 1 1 4 4 2 1 2 1 1 2 2 2 2 4 4 4 2 2 1 4 4 2 4 1
[556] 2 1 4 4 1 1 2 1 2 2 2 1 2 4 2 1 2 2 4 1 1 1 1 2 4 4 4 1 1 1 2 1 4 2 1 4 4
[593] 4 2 4 1 2 2 2 2 2 2 1 2 2 1 2 2 2 4 1 4 4 2 4 2 2 4 4 1 1 4 2 1 2 1 2 2 1
[630] 2 4 1 4 1 4 4 2 4 2 1 1 4 1 2 2 4 2 4 1 2 1 4 2 2 2 4 4 4 2 1 2 1 4 2 2 2
[667] 2 1 2 4 1 2 1 2 2 1 4 1 4 2 2 2 4 1 2 4 2 1 4 1 2 2 1 4 2 4 2 2 4 2 1 1 2
[704] 2 1 1 3 2 4 2 1 1 1 1 2 1 2 2 1 1 2 1 2 1 2 4 1 2 4 1 1 1 2 1 4 4 1 1 1 2
[741] 1 2 2 1 2 4 2 4 2 1 2 4 2 2 2 4 1 4 4 4 1 1 4 1 1 4 2 2 1 2 4 1 1 4 2 2 1
[778] 1 1 4 1 2 1 1 4 4 1 4 1 2 4 2 1 1 2 4 2 1 1 2 2 4 2 2 1 4 2 1 4 4 1 4 2 4
[815] 4 4 2 1 1 2 4 1 2 1 1 4 2 1 4 4 2 2 1 4 4 1 4 2 2 2 2 2 2 1 2 4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># Tamaño de cada uno de los grupos</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>vehicle_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>size</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 268 324   8 246</code></pre>
</div>
</div>
<p>Veamos ahora como se corresponde la clasificación del algoritmo con los valores originales:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="fu">table</span>(y_vehicle, vehicle_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.kmeans<span class="sc">$</span>model<span class="sc">$</span>cluster)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         
y_vehicle   1   2   3   4
     bus   50  80   2  86
     opel 112  65   0  35
     saab 106  73   0  38
     van    0 106   6  87</code></pre>
</div>
</div>
<p>La agrupación es similar e incluso un poco peor que la del modelo jerárquico como podemos comprobar al analizar el score correspondiente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># Predicción para cada modelo</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="co"># Valores de scores</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_vehicle)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.2467293 </code></pre>
</div>
</div>
<p>El resultado con el algoritmo de k-medias es muy inferior al del modelo jerárquico, o que nos haría decantarnos por este último para este banco de datos.</p>
</section>
</section>
<section id="sales-1" class="level4" data-number="18.4.2.3">
<h4 data-number="18.4.2.3" class="anchored" data-anchor-id="sales-1"><span class="header-section-number">18.4.2.3</span> Sales</h4>
<p>Finalizamos estos primeros modelos con el banco de datos de ventas. Procedemos de la misma forma que en ejemplos anteriores salvo por el hecho de que ahora no tenemos target y no podemos comparar nuestros resultados.</p>
<section id="modelo-de-agrupación-jerárquica-2" class="level5">
<h5 class="anchored" data-anchor-id="modelo-de-agrupación-jerárquica-2">Modelo de agrupación jerárquica</h5>
<p>De nuevo utilizamos el método de Ward para obtener la solución jerárquica y escalamos los valores de las características.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a><span class="co"># Preprocesamiento</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>pp_sales <span class="ot">=</span>  </span>
<span id="cb35-3"><a href="#cb35-3"></a>   <span class="fu">po</span>(<span class="st">"scale"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale =</span> <span class="cn">TRUE</span>))</span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb35-6"><a href="#cb35-6"></a>sales_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_sales <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)</span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb35-10"><a href="#cb35-10"></a>pr1 <span class="ot">=</span> sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)<span class="sc">$</span><span class="fu">predict</span>(tsk_sales)</span>
<span id="cb35-11"><a href="#cb35-11"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_sales)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.7478163 </code></pre>
</div>
</div>
<p>El coeficientes es bastante alto indicando que el modelo es capaz de establecer grupos más o menos homogéneos. Veamos el dendograma correspondiente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>modelo <span class="ot">=</span> sales_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-022-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>En este caso se podría optar por una solución con tres o cuatro clusters. En este caso vamos a seleccionar la solución con cuatro grupos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="fu">rect.hclust</span>(modelo, <span class="at">k =</span> <span class="dv">4</span>, <span class="at">border =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-023-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>A la vista del dendograma una solución con 4 grupos parece bastante buena para definir grupos homogéneos. En este caso vamos a caracterizar los grupos en función de las ventas realizadas en cada una de las semanas. para ellos añadiremos el grupo de pertenencia de cada muestra la banco de datos original, y realizaremos un estudio descriptivo y gráfico de ellos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">4</span>)</span>
<span id="cb39-3"><a href="#cb39-3"></a>sales_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_sales <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>pr1 <span class="ot">=</span> sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)<span class="sc">$</span><span class="fu">predict</span>(tsk_sales)</span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="co"># Añadimos columna  de asignación (en formato factor) a matriz de datos de ventas</span></span>
<span id="cb39-7"><a href="#cb39-7"></a>X_sales<span class="sc">$</span>grupo <span class="ot">=</span> <span class="fu">as.factor</span>(pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una vez tenemos el dataframe con los datos originales y el grupo asignado calculamos las medias de cada variable para cada uno de los grupos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>resumen <span class="ot">=</span> X_sales <span class="sc">%&gt;%</span> </span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="fu">group_by</span>(grupo) <span class="sc">%&gt;%</span> </span>
<span id="cb40-3"><a href="#cb40-3"></a>  <span class="fu">summarise_all</span>(mean)</span>
<span id="cb40-4"><a href="#cb40-4"></a>resumen</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4 × 53
  grupo     W0     W1     W2     W3     W4     W5     W6     W7     W8     W9
  &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
1 1     12.2   12.0   12.2   12.4   12.6   12.8   12.6   12.4   12.7   12.7  
2 2      3.25   3.48   3.42   3.61   3.61   3.58   3.71   3.99   3.55   3.72 
3 3     34.0   35.6   37.1   38.6   37.2   36.3   38.0   37.1   38.6   37.5  
4 4      0.231  0.221  0.217  0.221  0.298  0.251  0.281  0.221  0.234  0.258
# ℹ 42 more variables: W10 &lt;dbl&gt;, W11 &lt;dbl&gt;, W12 &lt;dbl&gt;, W13 &lt;dbl&gt;, W14 &lt;dbl&gt;,
#   W15 &lt;dbl&gt;, W16 &lt;dbl&gt;, W17 &lt;dbl&gt;, W18 &lt;dbl&gt;, W19 &lt;dbl&gt;, W20 &lt;dbl&gt;,
#   W21 &lt;dbl&gt;, W22 &lt;dbl&gt;, W23 &lt;dbl&gt;, W24 &lt;dbl&gt;, W25 &lt;dbl&gt;, W26 &lt;dbl&gt;,
#   W27 &lt;dbl&gt;, W28 &lt;dbl&gt;, W29 &lt;dbl&gt;, W30 &lt;dbl&gt;, W31 &lt;dbl&gt;, W32 &lt;dbl&gt;,
#   W33 &lt;dbl&gt;, W34 &lt;dbl&gt;, W35 &lt;dbl&gt;, W36 &lt;dbl&gt;, W37 &lt;dbl&gt;, W38 &lt;dbl&gt;,
#   W39 &lt;dbl&gt;, W40 &lt;dbl&gt;, W41 &lt;dbl&gt;, W42 &lt;dbl&gt;, W43 &lt;dbl&gt;, W44 &lt;dbl&gt;,
#   W45 &lt;dbl&gt;, W46 &lt;dbl&gt;, W47 &lt;dbl&gt;, W48 &lt;dbl&gt;, W49 &lt;dbl&gt;, W50 &lt;dbl&gt;, …</code></pre>
</div>
</div>
<p>El problema es que a tabla es demasiado grande y por tanto resulta difícil extraer conclusiones. Recolocamos los datos para poder representarlos gráficamente. Hacemos uso de la función <code>pivot_longer</code> que nos permite reestructurar los datos en un formato que la función gráfica puede interpretar fácilmente. Para utilizar esta función debemos identificar los nombres de las variables que deseamos reorganizar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="co"># Reorganizamos los datos para tener solo tres columnas: grupo, semana, y ventas</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>df <span class="ot">=</span> resumen <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">colnames</span>(resumen[,<span class="dv">2</span><span class="sc">:</span><span class="fu">ncol</span>(resumen)]), <span class="at">names_to =</span> <span class="st">"W"</span>, <span class="at">values_to =</span> <span class="st">"Sales"</span>) </span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(W, Sales, <span class="at">col =</span> grupo)) <span class="sc">+</span> <span class="fu">geom_point</span>()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-026-1.png" class="img-fluid" width="1344"></p>
</div>
</div>
<p>El gráfico de medias nos permite identificar claramente las características de cada uno de los grupos. Por ejemplo, el grupo 3 viene caracterizado por las mayores ventas en todas las semanas, mientras que el cuatro contiene las ventas semanales más bajas. En este caso no establecemos el algoritmo de k-medias ya que no tenemos información suficiente para establecer el número de clusters inicial. Podríamos plantear soluciones para diferentes valores de <code>k</code> y seleccionar aquel con el mejor score.</p>
<p>Una vez hemos visto los modelos de cluster aplicados directamente sobre los bancos de datos originales, vamos a ver como utilizar el algoritmo de componentes principales para refinar nuestras agrupaciones y conseguir soluciones más eficientes y que nos permitan caracterizar los datos de forma más precisa.</p>
</section>
</section>
</section>
<section id="sec-180.4.3" class="level3" data-number="18.4.3">
<h3 data-number="18.4.3" class="anchored" data-anchor-id="sec-180.4.3"><span class="header-section-number">18.4.3</span> Modelos de agrupación con CP</h3>
<p>Comenzaremos todos los análisis determinado el número óptimo de componentes. A continuación extraeremos las coordenadas de todas las muestras en dichas componentes y procederemos con el análisis cluster. Como criterio valoraremos el número de componentes de las soluciones donde alcanzamos el 50%, 70%, y 80% de variabilidad explicada. Una vez establecido dicho número utilizaremos el pipeop <code>pca</code> para realizar el preprocesado de datos mediante componentes principales.</p>
<section id="gene-expression-leukemia-2" class="level4" data-number="18.4.3.1">
<h4 data-number="18.4.3.1" class="anchored" data-anchor-id="gene-expression-leukemia-2"><span class="header-section-number">18.4.3.1</span> Gene expression leukemia</h4>
<p>Comenzamos con el análisis de CP y la selección del número de componentes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="co"># CP</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>leukemia_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_genes, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="co"># Resumen numérico del análisis</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>resumen_cp <span class="ot">=</span> <span class="fu">get_eigenvalue</span>(leukemia_cp)</span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="co"># Componentes para el 50% de VE</span></span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">50</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5</code></pre>
</div>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># Componentes para el 70% de VE</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">70</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 13</code></pre>
</div>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># Componentes para el 80% de VE</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">80</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 22</code></pre>
</div>
</div>
<p>En este caso hay una gran diferencia en el número de componentes entre todas soluciones, aunque dado el gran número de variables originales (22283) es hasta cierto punto el comportamiento esperado. Para ver la potencia del análisis empezamos con la solución con cuatro componentes. Analizamos únicamente la solución del modelo jerárquico.</p>
<p>Establecemos el modelo de aprendizaje utilizando el preprocesado adecuado, y obtenemos el score correspondiente para comparar con el modelo sin preprocesado de CP:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb49-3"><a href="#cb49-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">5</span>))</span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb49-6"><a href="#cb49-6"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb49-8"><a href="#cb49-8"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span>
<span id="cb49-9"><a href="#cb49-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb49-10"><a href="#cb49-10"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb49-12"><a href="#cb49-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.1256943 </code></pre>
</div>
</div>
<p>El score ha mejorado algo con respecto al modelo sin CP pero todavía resulta muy bajo. Veamos que ocurre si cambiamos la solución con 13 componentes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb51-3"><a href="#cb51-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">13</span>))</span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb51-5"><a href="#cb51-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb51-6"><a href="#cb51-6"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb51-7"><a href="#cb51-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb51-8"><a href="#cb51-8"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span>
<span id="cb51-9"><a href="#cb51-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb51-11"><a href="#cb51-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb51-12"><a href="#cb51-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.1205582 </code></pre>
</div>
</div>
<p>El coeficiente empeora el resultado anterior. Veamos que ocurre en el último caso:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb53-3"><a href="#cb53-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">22</span>))</span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb53-6"><a href="#cb53-6"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb53-7"><a href="#cb53-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb53-8"><a href="#cb53-8"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span>
<span id="cb53-9"><a href="#cb53-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb53-11"><a href="#cb53-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb53-12"><a href="#cb53-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_genes)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.1256943 </code></pre>
</div>
</div>
<p>A la vista de los resultados parece que una solución con cinco componentes es suficiente. En primer lugar vemos el dendograma correspondiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb55-3"><a href="#cb55-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">5</span>))</span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb55-5"><a href="#cb55-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb55-6"><a href="#cb55-6"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb55-7"><a href="#cb55-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb55-8"><a href="#cb55-8"></a>genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)</span>
<span id="cb55-9"><a href="#cb55-9"></a><span class="co"># Dendograma</span></span>
<span id="cb55-10"><a href="#cb55-10"></a>modelo <span class="ot">=</span> genes_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb55-11"><a href="#cb55-11"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-031-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En este caso no queda clara que una solución con cinco clusters parece acertada, a pesar de que el target tiene cinco grupos. Veamos como se corresponden los clusters obtenidos con dicha variable. Planteamos cinco grupos para mantener la equivalencia con el target original.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">5</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a>genes_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_genes <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb56-5"><a href="#cb56-5"></a>pr1 <span class="ot">=</span> genes_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_genes)<span class="sc">$</span><span class="fu">predict</span>(tsk_genes)</span>
<span id="cb56-6"><a href="#cb56-6"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb56-7"><a href="#cb56-7"></a><span class="fu">table</span>(y_genes<span class="sc">$</span>type, pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                  
                    1  2  3  4  5
  AML               2 16  3  5  0
  Bone_Marrow       0  0 10  0  0
  Bone_Marrow_CD34  7  1  0  0  0
  PB                0  0  0  0 10
  PBSC_CD34        10  0  0  0  0</code></pre>
</div>
</div>
<p>En este caso si ocurre que algunos cluster identifican mayoritariamente cada tipo de tumor. El más problemático es el cluster 1 con los tipos <code>AML</code>, <code>Bone_Marrow_CD34</code>, y <code>PBSC_CD34</code>. Vista la agrupación obtenida la caracterización de los clusters que nos puede aportar información muy relevante sobre las características de cada tipo de tumor. Extraemos las coordenadas en las 5 componentes y las unimos con la solución obtenida.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="co"># Obtención de coordenadas</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>leukemia_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_genes, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb58-3"><a href="#cb58-3"></a>coor_cp <span class="ot">=</span> <span class="fu">as.data.frame</span>(<span class="fu">get_pca_ind</span>(leukemia_cp)<span class="sc">$</span>coord[,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>])</span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="co"># Fusión de datos</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>coor_cp<span class="sc">$</span>cluster <span class="ot">=</span> <span class="fu">as.factor</span>(pr1<span class="sc">$</span>partition)</span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="fu">colnames</span>(coor_cp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"D01"</span>, <span class="st">"D02"</span>,<span class="st">"D03"</span>,<span class="st">"D04"</span>,<span class="st">"D05"</span>)</span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="co"># Gráfico descriptivo de componentes</span></span>
<span id="cb58-8"><a href="#cb58-8"></a>df <span class="ot">=</span> coor_cp <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">colnames</span>(coor_cp[,<span class="dv">1</span><span class="sc">:</span>(<span class="fu">ncol</span>(coor_cp)<span class="sc">-</span><span class="dv">1</span>)]), <span class="at">names_to =</span> <span class="st">"CP"</span>, <span class="at">values_to =</span> <span class="st">"Coordenadas"</span>) </span>
<span id="cb58-9"><a href="#cb58-9"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(cluster, Coordenadas)) <span class="sc">+</span> </span>
<span id="cb58-10"><a href="#cb58-10"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span></span>
<span id="cb58-11"><a href="#cb58-11"></a>  <span class="fu">facet_wrap</span>(<span class="fu">vars</span>(CP), <span class="at">nrow =</span> <span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-033-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Como era de esperar, por la misma construcción de las componentes, las mayores diferencias entre los clusters se observan en las primera dimensiones. Por ejemplo, en la primera componente podemos establecer el orden siguiente en función de los valores observados (en orden descendente): C5 &gt; C2 &gt; C3 &gt; C4 &gt; C1, lo que implica teniendo en cuenta la tabla de coincidencias entre clasificación y valores originales, que las leucemias del tipo <code>PB</code> se pueden identificar si buscamos los valores más altos en la primera componente. Por otro lado los valores más bajos en dicha componente se pueden asociar con las leucemias de los tipos <code>PBSC_CD34</code>, <code>AML</code>, y <code>Bone_Marrow_CD34</code>. Así mismo podemos ver que los valores más bajos en la componente 2 se corresponden con el grupo 5 (<code>PB</code>), y los más altos con los grupos 1 y 2 (<code>AML</code>, <code>Bone_Marrow_CD34</code>). Veamos estas conclusiones de forma gráfica:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># Añadimos el tipo de leucemia a las coordenadas y el cluster.</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>coor_cp<span class="sc">$</span>type <span class="ot">=</span> y_genes<span class="sc">$</span>type</span>
<span id="cb59-3"><a href="#cb59-3"></a><span class="co"># Gráfico</span></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="fu">ggplot</span>(coor_cp, <span class="fu">aes</span>(D01, D02, <span class="at">color =</span> cluster, <span class="at">shape =</span> type)) <span class="sc">+</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-034-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>En el gráfico se observa claramente que el cluster 5 esta asociado con <code>PB</code> y se sitúa sobre el cuadrante IV. En los otros cuatro grupos hay mezclas de diferentes tipos de leucemia, aunque geográficamente si se aprecia cierta separación entre los diferentes cluster.</p>
</section>
<section id="vehicle-silhouettes-2" class="level4" data-number="18.4.3.2">
<h4 data-number="18.4.3.2" class="anchored" data-anchor-id="vehicle-silhouettes-2"><span class="header-section-number">18.4.3.2</span> Vehicle silhouettes</h4>
<p>Comenzamos con el análisis de CP y la selección del número de componentes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a><span class="co"># CP</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>vehicle_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_vehicle, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="co"># Resumen numérico del análisis</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>resumen_cp <span class="ot">=</span> <span class="fu">get_eigenvalue</span>(vehicle_cp)</span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="co"># Componentes para el 50% de VE</span></span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">50</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># Componentes para el 70% de VE</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">70</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="co"># Componentes para el 80% de VE </span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">80</span>) <span class="sc">+</span> <span class="dv">1</span> </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4</code></pre>
</div>
</div>
<p>En este caso seleccionamos cuatro componentes ya que no añadimos mucha complejidad (muchas componentes) pero si ganamos un 10% de variabilidad explicada.</p>
<p>Establecemos el modelo de aprendizaje utilizando el preprocesado adecuado, y obtenemos el score correspondiente para comparar con el modelo sin preprocesado de CP:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb66-2"><a href="#cb66-2"></a>pp_vehicle <span class="ot">=</span>  </span>
<span id="cb66-3"><a href="#cb66-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">4</span>))</span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb66-6"><a href="#cb66-6"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb66-7"><a href="#cb66-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb66-8"><a href="#cb66-8"></a>vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)</span>
<span id="cb66-9"><a href="#cb66-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb66-10"><a href="#cb66-10"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb66-11"><a href="#cb66-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb66-12"><a href="#cb66-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_vehicle)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
       0.6651938 </code></pre>
</div>
</div>
<p>El valor obtenido del índice es superior al del modelo jerárquico original. Veamos el dendograma asociado:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb68-2"><a href="#cb68-2"></a>pp_genes <span class="ot">=</span>  </span>
<span id="cb68-3"><a href="#cb68-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">4</span>))</span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb68-5"><a href="#cb68-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb68-6"><a href="#cb68-6"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb68-7"><a href="#cb68-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb68-8"><a href="#cb68-8"></a>vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)</span>
<span id="cb68-9"><a href="#cb68-9"></a><span class="co"># Dendograma</span></span>
<span id="cb68-10"><a href="#cb68-10"></a>modelo <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb68-11"><a href="#cb68-11"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-037-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Como en el caso anterior vamos a mantener la solución con cuatro clusters para poder comparar la solución con el target original.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb69-2"><a href="#cb69-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">4</span>)</span>
<span id="cb69-3"><a href="#cb69-3"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb69-5"><a href="#cb69-5"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb69-6"><a href="#cb69-6"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb69-7"><a href="#cb69-7"></a><span class="fu">table</span>(y_vehicle, pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         
y_vehicle   1   2   3   4
     bus   44  63  56  55
     opel  44  35 116  17
     saab  53  35 110  19
     van   68  55   0  76</code></pre>
</div>
</div>
<p>Se puede ver una gran mezcla en todos los clusters. Ahora caracterizamos los grupos en función de las coordenadas en las componentes principales consideradas:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1"></a><span class="co"># Obtenición de coordenadas</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>vehicle_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_vehicle, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb71-3"><a href="#cb71-3"></a>coor_cp <span class="ot">=</span> <span class="fu">as.data.frame</span>(<span class="fu">get_pca_ind</span>(vehicle_cp)<span class="sc">$</span>coord[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])</span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="co"># Fusión de datos</span></span>
<span id="cb71-5"><a href="#cb71-5"></a>coor_cp<span class="sc">$</span>cluster <span class="ot">=</span> <span class="fu">as.factor</span>(pr1<span class="sc">$</span>partition)</span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="fu">colnames</span>(coor_cp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"D01"</span>, <span class="st">"D02"</span>,<span class="st">"D03"</span>,<span class="st">"D04"</span>)</span>
<span id="cb71-7"><a href="#cb71-7"></a><span class="co"># Gráfico descriptivo de componentes</span></span>
<span id="cb71-8"><a href="#cb71-8"></a>df <span class="ot">=</span> coor_cp <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">colnames</span>(coor_cp[,<span class="dv">1</span><span class="sc">:</span>(<span class="fu">ncol</span>(coor_cp)<span class="sc">-</span><span class="dv">1</span>)]), <span class="at">names_to =</span> <span class="st">"CP"</span>, <span class="at">values_to =</span> <span class="st">"Coordenadas"</span>) </span>
<span id="cb71-9"><a href="#cb71-9"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(cluster, Coordenadas)) <span class="sc">+</span> </span>
<span id="cb71-10"><a href="#cb71-10"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span></span>
<span id="cb71-11"><a href="#cb71-11"></a>  <span class="fu">facet_wrap</span>(<span class="fu">vars</span>(CP), <span class="at">nrow =</span> <span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-039-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>¿Cómo interpretamos ahora los gráficos anteriores? Para finalizar utilizamos las dos primeras componentes para la representación gráfica de los clusters y target.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1"></a><span class="co"># Añadimos el tipo de leucemia a las coordenadas y el cluster.</span></span>
<span id="cb72-2"><a href="#cb72-2"></a>coor_cp<span class="sc">$</span>vehicle <span class="ot">=</span> y_vehicle</span>
<span id="cb72-3"><a href="#cb72-3"></a><span class="co"># Gráfico</span></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="fu">ggplot</span>(coor_cp, <span class="fu">aes</span>(D01, D02, <span class="at">color =</span> cluster, <span class="at">shape =</span> vehicle)) <span class="sc">+</span></span>
<span id="cb72-5"><a href="#cb72-5"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-040-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Aunque el gráfico de dispersión es capaz de separar los cuatro grupos (ese es el motivo por el que el índice es alto), también es cierto que la mezcla de tipos de vehículos es muy grande impidiendo una clasificación clara de todos ellos. tal vez si se aumenta el número de grupos podríamos tener una solución más efectiva. Vamos a ver que ocurre si consideramos 8 grupos en lugar de cuatro que parece una solución más adecuada para la obtención de clusters homogéneos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>, <span class="at">k =</span> <span class="dv">8</span>)</span>
<span id="cb73-3"><a href="#cb73-3"></a>vehicle_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_vehicle <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="co"># Valores de predicción</span></span>
<span id="cb73-5"><a href="#cb73-5"></a>pr1 <span class="ot">=</span> vehicle_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_vehicle)<span class="sc">$</span><span class="fu">predict</span>(tsk_vehicle)</span>
<span id="cb73-6"><a href="#cb73-6"></a><span class="co"># Generamos la tabla de comparación</span></span>
<span id="cb73-7"><a href="#cb73-7"></a><span class="fu">table</span>(y_vehicle, pr1<span class="sc">$</span>partition)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         
y_vehicle  1  2  3  4  5  6  7  8
     bus  22  1 36  2 22 53 20 62
     opel 15 33 88  0 29 17 28  2
     saab 16 32 83  0 37 19 27  3
     van  39 55  0  6 29 70  0  0</code></pre>
</div>
</div>
<p>El reparto sigue siendo similar lo que nos impedirá obtener una buena clasificación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1"></a><span class="co"># Obtención de coordenadas</span></span>
<span id="cb75-2"><a href="#cb75-2"></a>vehicle_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_vehicle, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb75-3"><a href="#cb75-3"></a>coor_cp <span class="ot">=</span> <span class="fu">as.data.frame</span>(<span class="fu">get_pca_ind</span>(vehicle_cp)<span class="sc">$</span>coord[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])</span>
<span id="cb75-4"><a href="#cb75-4"></a><span class="co"># Fusión de datos</span></span>
<span id="cb75-5"><a href="#cb75-5"></a>coor_cp<span class="sc">$</span>cluster <span class="ot">=</span> <span class="fu">as.factor</span>(pr1<span class="sc">$</span>partition)</span>
<span id="cb75-6"><a href="#cb75-6"></a><span class="fu">colnames</span>(coor_cp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"D01"</span>, <span class="st">"D02"</span>,<span class="st">"D03"</span>,<span class="st">"D04"</span>)</span>
<span id="cb75-7"><a href="#cb75-7"></a><span class="co"># Gráfico descriptivo de componentes</span></span>
<span id="cb75-8"><a href="#cb75-8"></a>df <span class="ot">=</span> coor_cp <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">colnames</span>(coor_cp[,<span class="dv">1</span><span class="sc">:</span>(<span class="fu">ncol</span>(coor_cp)<span class="sc">-</span><span class="dv">1</span>)]), <span class="at">names_to =</span> <span class="st">"CP"</span>, <span class="at">values_to =</span> <span class="st">"Coordenadas"</span>) </span>
<span id="cb75-9"><a href="#cb75-9"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(cluster, Coordenadas)) <span class="sc">+</span> </span>
<span id="cb75-10"><a href="#cb75-10"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span></span>
<span id="cb75-11"><a href="#cb75-11"></a>  <span class="fu">facet_wrap</span>(<span class="fu">vars</span>(CP), <span class="at">nrow =</span> <span class="dv">2</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-042-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Al aumentar el número de clusters resulta más difícil extraer conclusiones sobre las características de los grupos- Veamos el gráfico de dispersión.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a><span class="co"># Añadimos el tipo de leucemia a las coordenadas y el cluster.</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>coor_cp<span class="sc">$</span>vehicle <span class="ot">=</span> y_vehicle</span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="co"># Gráfico</span></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="fu">ggplot</span>(coor_cp, <span class="fu">aes</span>(D01, D02, <span class="at">color =</span> cluster, <span class="at">shape =</span> vehicle)) <span class="sc">+</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-043-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Aunque algunos grupos se identifican más claramente, también es cierto que en el cuadrante I hay una gran mezcla de subgrupos. Esta claro que el modelo de cluster no es capaz de clasificar adecuadamente este tipo de datos.</p>
</section>
<section id="sales-2" class="level4" data-number="18.4.3.3">
<h4 data-number="18.4.3.3" class="anchored" data-anchor-id="sales-2"><span class="header-section-number">18.4.3.3</span> Sales</h4>
<p>Ampliamos ahora el análisis del banco de datos <code>Sales</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a>X_sales <span class="ot">=</span> sales <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>Product_Code)</span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="co"># CP</span></span>
<span id="cb77-3"><a href="#cb77-3"></a>sales_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_sales, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="co"># Resumen numérico del análisis</span></span>
<span id="cb77-5"><a href="#cb77-5"></a>resumen_cp <span class="ot">=</span> <span class="fu">get_eigenvalue</span>(sales_cp)</span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="co"># Componentes para el 50% de VE</span></span>
<span id="cb77-7"><a href="#cb77-7"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">50</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1"></a><span class="co"># Componentes para el 70% de VE</span></span>
<span id="cb79-2"><a href="#cb79-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">70</span>) <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1"></a><span class="co"># Componentes para el 80% de VE </span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="fu">sum</span>(resumen_cp<span class="sc">$</span>cumulative.variance.percent <span class="sc">&lt;=</span> <span class="dv">80</span>) <span class="sc">+</span> <span class="dv">1</span> </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>Con la primera componente ya superamos el 80% de variabilidad explicada. Veamos toda la solución:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1"></a>resumen_cp </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        eigenvalue variance.percent cumulative.variance.percent
Dim.1  47.78910144      91.90211815                    91.90212
Dim.2   0.55213123       1.06179082                    92.96391
Dim.3   0.14797491       0.28456713                    93.24848
Dim.4   0.13595480       0.26145153                    93.50993
Dim.5   0.13219255       0.25421643                    93.76414
Dim.6   0.13080692       0.25155177                    94.01570
Dim.7   0.12715229       0.24452364                    94.26022
Dim.8   0.12416468       0.23877824                    94.49900
Dim.9   0.11564483       0.22239391                    94.72139
Dim.10  0.11108205       0.21361932                    94.93501
Dim.11  0.10604851       0.20393943                    95.13895
Dim.12  0.10381895       0.19965183                    95.33860
Dim.13  0.10118217       0.19458110                    95.53318
Dim.14  0.09765755       0.18780299                    95.72099
Dim.15  0.09366446       0.18012396                    95.90111
Dim.16  0.09062670       0.17428211                    96.07539
Dim.17  0.09004999       0.17317305                    96.24857
Dim.18  0.08702323       0.16735237                    96.41592
Dim.19  0.08581850       0.16503558                    96.58095
Dim.20  0.08313023       0.15986583                    96.74082
Dim.21  0.08106007       0.15588475                    96.89670
Dim.22  0.07692514       0.14793296                    97.04464
Dim.23  0.07608205       0.14631163                    97.19095
Dim.24  0.07418541       0.14266425                    97.33361
Dim.25  0.07358190       0.14150365                    97.47512
Dim.26  0.07174831       0.13797751                    97.61309
Dim.27  0.06924151       0.13315674                    97.74625
Dim.28  0.06717177       0.12917649                    97.87543
Dim.29  0.06491290       0.12483251                    98.00026
Dim.30  0.06293675       0.12103221                    98.12129
Dim.31  0.06094855       0.11720874                    98.23850
Dim.32  0.05962049       0.11465479                    98.35316
Dim.33  0.05791753       0.11137986                    98.46454
Dim.34  0.05652227       0.10869668                    98.57323
Dim.35  0.05327825       0.10245817                    98.67569
Dim.36  0.05087133       0.09782947                    98.77352
Dim.37  0.05065133       0.09740639                    98.87093
Dim.38  0.04912207       0.09446553                    98.96539
Dim.39  0.04770308       0.09173669                    99.05713
Dim.40  0.04626510       0.08897135                    99.14610
Dim.41  0.04385967       0.08434552                    99.23045
Dim.42  0.04285923       0.08242160                    99.31287
Dim.43  0.04274532       0.08220255                    99.39507
Dim.44  0.04171343       0.08021814                    99.47529
Dim.45  0.04013695       0.07718644                    99.55247
Dim.46  0.03864668       0.07432054                    99.62679
Dim.47  0.03581958       0.06888381                    99.69568
Dim.48  0.03556097       0.06838648                    99.76406
Dim.49  0.03328233       0.06400448                    99.82807
Dim.50  0.03219051       0.06190483                    99.88997
Dim.51  0.03014952       0.05797985                    99.94795
Dim.52  0.02706401       0.05204618                   100.00000</code></pre>
</div>
</div>
<p>Con las dos primeras CP alcanzamos un 92% de variabilidad explicada y optamos por esta solución para proceder con el análisis cluster.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb85-2"><a href="#cb85-2"></a>pp_sales <span class="ot">=</span>  </span>
<span id="cb85-3"><a href="#cb85-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">2</span>))</span>
<span id="cb85-4"><a href="#cb85-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb85-5"><a href="#cb85-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb85-6"><a href="#cb85-6"></a>sales_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_sales <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb85-7"><a href="#cb85-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb85-8"><a href="#cb85-8"></a>sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)</span>
<span id="cb85-9"><a href="#cb85-9"></a><span class="co"># Valoración del modelo</span></span>
<span id="cb85-10"><a href="#cb85-10"></a>pr1 <span class="ot">=</span> sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)<span class="sc">$</span><span class="fu">predict</span>(tsk_sales)</span>
<span id="cb85-11"><a href="#cb85-11"></a><span class="co"># Valores de scores</span></span>
<span id="cb85-12"><a href="#cb85-12"></a>pr1<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"clust.silhouette"</span>), <span class="at">task =</span> tsk_sales)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>clust.silhouette 
        0.751676 </code></pre>
</div>
</div>
<p>El score ha mejorado teniendo en cuenta que hemos reducido a un análisis solo con dos predictoras. procedemos con el resto del análisis. Veamos el dendograma:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1"></a><span class="co"># Preprocesado</span></span>
<span id="cb87-2"><a href="#cb87-2"></a>pp_sales <span class="ot">=</span>  </span>
<span id="cb87-3"><a href="#cb87-3"></a>   <span class="fu">po</span>(<span class="st">"pca"</span>, <span class="at">param_vals =</span> <span class="fu">list</span>(<span class="at">center =</span> <span class="cn">TRUE</span>, <span class="at">scale. =</span> <span class="cn">TRUE</span>, <span class="at">rank. =</span> <span class="dv">2</span>))</span>
<span id="cb87-4"><a href="#cb87-4"></a><span class="co"># Modelo de aprendizaje</span></span>
<span id="cb87-5"><a href="#cb87-5"></a>lrn1 <span class="ot">=</span> <span class="fu">lrn</span>(<span class="st">"clust.hclust"</span>, <span class="at">method =</span> <span class="st">"ward.D"</span>, <span class="at">distmethod =</span> <span class="st">"euclidean"</span>)</span>
<span id="cb87-6"><a href="#cb87-6"></a>sales_lrn1 <span class="ot">=</span> <span class="fu">as_learner</span>(pp_sales <span class="sc">%&gt;&gt;%</span> lrn1)</span>
<span id="cb87-7"><a href="#cb87-7"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb87-8"><a href="#cb87-8"></a>sales_lrn1<span class="sc">$</span><span class="fu">train</span>(tsk_sales)</span>
<span id="cb87-9"><a href="#cb87-9"></a><span class="co"># Dendograma</span></span>
<span id="cb87-10"><a href="#cb87-10"></a>modelo <span class="ot">=</span> sales_lrn1<span class="sc">$</span>model<span class="sc">$</span>clust.hclust<span class="sc">$</span>model</span>
<span id="cb87-11"><a href="#cb87-11"></a><span class="fu">plot</span>(<span class="fu">as.dendrogram</span>(modelo))</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-047-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Una solución con cinco grupos parece construir grupos homogéneos y distintos entre si. Veamos con algo más detalle esta solución tratando de caracterizar los grupos obtenidos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1"></a><span class="co"># Obtención de coordenadas</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>sales_cp <span class="ot">=</span> <span class="fu">prcomp</span>(X_sales, <span class="at">scale =</span> <span class="cn">TRUE</span>)</span>
<span id="cb88-3"><a href="#cb88-3"></a>coor_cp <span class="ot">=</span> <span class="fu">as.data.frame</span>(<span class="fu">get_pca_ind</span>(sales_cp)<span class="sc">$</span>coord[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>])</span>
<span id="cb88-4"><a href="#cb88-4"></a><span class="co"># Fusión de datos</span></span>
<span id="cb88-5"><a href="#cb88-5"></a>coor_cp<span class="sc">$</span>cluster <span class="ot">=</span> <span class="fu">as.factor</span>(pr1<span class="sc">$</span>partition)</span>
<span id="cb88-6"><a href="#cb88-6"></a><span class="fu">colnames</span>(coor_cp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"D01"</span>, <span class="st">"D02"</span>)</span>
<span id="cb88-7"><a href="#cb88-7"></a><span class="co"># Gráfico descriptivo de componentes</span></span>
<span id="cb88-8"><a href="#cb88-8"></a>df <span class="ot">=</span> coor_cp <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">colnames</span>(coor_cp[,<span class="dv">1</span><span class="sc">:</span>(<span class="fu">ncol</span>(coor_cp)<span class="sc">-</span><span class="dv">1</span>)]), <span class="at">names_to =</span> <span class="st">"CP"</span>, <span class="at">values_to =</span> <span class="st">"Coordenadas"</span>) </span>
<span id="cb88-9"><a href="#cb88-9"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(cluster, Coordenadas)) <span class="sc">+</span> </span>
<span id="cb88-10"><a href="#cb88-10"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span></span>
<span id="cb88-11"><a href="#cb88-11"></a>  <span class="fu">facet_wrap</span>(<span class="fu">vars</span>(CP), <span class="at">nrow =</span> <span class="dv">1</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-048-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Como era de esperar casi toda la caracterización de los grupos se corresponde con la componente 1 ya que tenia más del 90% de variabilidad explicada. De acuerdo a ella nos resulta bastante fácil clasificar las diferentes semanas. El grupo 5 es que el que tiene los productos con mayores ventas y el grupo 4 el que tiene los productos con ventas más bajas. Veamos el gráfico de dispersión.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1"></a><span class="co"># Añadimos el tipo de leucemia a las coordenadas y el cluster.</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>coor_cp<span class="sc">$</span>product <span class="ot">=</span> y_sales<span class="sc">$</span>Product_Code</span>
<span id="cb89-3"><a href="#cb89-3"></a><span class="co"># Gráfico</span></span>
<span id="cb89-4"><a href="#cb89-4"></a><span class="fu">ggplot</span>(coor_cp, <span class="fu">aes</span>(D01, D02, <span class="at">color =</span> cluster)) <span class="sc">+</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="180_Clustermodels_files/figure-html/cluster-049-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Podemos identificar claramente los clusters de izquierda a derecha (de menos a más ventas). Esto nos permite identificar rápidamente patrones de productos sin necesidad de revisar toda la tabla de datos. Podemos ver por ejemplo los productos que se corresponden con las menores ventas (grupo 4) y las mayores ventas (grupo 5).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1"></a><span class="co"># Menores ventas</span></span>
<span id="cb90-2"><a href="#cb90-2"></a>coor_cp[coor_cp<span class="sc">$</span>cluster <span class="sc">==</span> <span class="dv">4</span>, <span class="st">"product"</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>character(0)</code></pre>
</div>
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1"></a><span class="co"># mayores ventas</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>coor_cp[coor_cp<span class="sc">$</span>cluster <span class="sc">==</span> <span class="dv">5</span>, <span class="st">"product"</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>character(0)</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="sec-180.5" class="level2" data-number="18.5">
<h2 data-number="18.5" class="anchored" data-anchor-id="sec-180.5"><span class="header-section-number">18.5</span> Ejercicios</h2>
<p>Consideramos diferentes ejercicios donde el target es categórico o numérico.</p>
<ol type="1">
<li>Ajustar un modelo de aprendizaje automático basado en algoritmo de cluster (independiente o como resultado de un preprocesado de componentes principales) para el banco de datos <code>Iris</code><a href="40_DataBases.html#sec-iris"><span>4.3.3</span></a>.</li>
<li>Ajustar un modelo de aprendizaje automático basado en algoritmo de cluster (independiente o como resultado de un preprocesado de componentes principales) para el banco de datos <code>Wine quality</code><a href="40_DataBases.html#sec-winequality"><span>4.3.8</span></a>.</li>
<li>Ajustar un modelo de aprendizaje automático basado en algoritmo de cluster (independiente o como resultado de un preprocesado de componentes principales) para el banco de datos <code>WGene expression breast cancer</code><a href="40_DataBases.html#sec-geneexp"><span>4.3.10</span></a>.</li>
<li>Ajustar un modelo de aprendizaje automático basado en algoritmo de cluster (independiente o como resultado de un preprocesado de componentes principales) para el banco de datos <code>QSAR</code><a href="40_DataBases.html#sec-qsar"><span>4.2.8</span></a>.</li>
<li>Ajustar un modelo de aprendizaje automático basado en algoritmo de cluster (independiente o como resultado de un preprocesado de componentes principales) para el banco de datos <code>Meat spec</code><a href="40_DataBases.html#sec-meatspec"><span>4.2.5</span></a>.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "¡Copiado!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "¡Copiado!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./170_MDSmodels.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Métodos de escalado multidimensional (MDS)</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">Referencias</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Copyright 2023, IA4LEGOS. Universidad Miguel Hernández de Elche</div>   
  </div>
</footer>



</body></html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MachineLearning - 4&nbsp; Aplicaciones Redes multicapa densas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./50_ConvNN.html" rel="next">
<link href="./30_RMDDL.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Aplicaciones Redes multicapa densas</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MachineLearning</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Deep Learning</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_IntroDL.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./20_TrainDL.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Entrenamiento de la red neuronal</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./30_RMDDL.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Redes multicapa densas con Keras</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./40_AplMD.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Aplicaciones Redes multicapa densas</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./50_ConvNN.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Redes convolucionales</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#conjuntos-de-datos" id="toc-conjuntos-de-datos" class="nav-link active" data-scroll-target="#conjuntos-de-datos"><span class="toc-section-number">4.1</span>  Conjuntos de datos</a>
  <ul>
  <li><a href="#diabetes" id="toc-diabetes" class="nav-link" data-scroll-target="#diabetes"><span class="toc-section-number">4.1.1</span>  Diabetes</a></li>
  <li><a href="#qsar" id="toc-qsar" class="nav-link" data-scroll-target="#qsar"><span class="toc-section-number">4.1.2</span>  Qsar</a></li>
  <li><a href="#water-potability" id="toc-water-potability" class="nav-link" data-scroll-target="#water-potability"><span class="toc-section-number">4.1.3</span>  Water potability</a></li>
  <li><a href="#breast-cancer-wisconsin" id="toc-breast-cancer-wisconsin" class="nav-link" data-scroll-target="#breast-cancer-wisconsin"><span class="toc-section-number">4.1.4</span>  Breast Cancer Wisconsin</a></li>
  </ul></li>
  <li><a href="#análisis-de-los-ejemplos" id="toc-análisis-de-los-ejemplos" class="nav-link" data-scroll-target="#análisis-de-los-ejemplos"><span class="toc-section-number">4.2</span>  Análisis de los ejemplos</a>
  <ul>
  <li><a href="#diabetes-1" id="toc-diabetes-1" class="nav-link" data-scroll-target="#diabetes-1"><span class="toc-section-number">4.2.1</span>  Diabetes</a>
  <ul class="collapse">
  <li><a href="#preprocesado" id="toc-preprocesado" class="nav-link" data-scroll-target="#preprocesado"><span class="toc-section-number">4.2.1.1</span>  Preprocesado</a></li>
  <li><a href="#nuestra-primera-rn" id="toc-nuestra-primera-rn" class="nav-link" data-scroll-target="#nuestra-primera-rn"><span class="toc-section-number">4.2.1.2</span>  Nuestra primera RN</a></li>
  <li><a href="#actualizando-nuestra-red-neuronal" id="toc-actualizando-nuestra-red-neuronal" class="nav-link" data-scroll-target="#actualizando-nuestra-red-neuronal"><span class="toc-section-number">4.2.1.3</span>  Actualizando nuestra red neuronal</a></li>
  </ul></li>
  <li><a href="#qsar-1" id="toc-qsar-1" class="nav-link" data-scroll-target="#qsar-1"><span class="toc-section-number">4.2.2</span>  Qsar</a>
  <ul class="collapse">
  <li><a href="#preprocesado-1" id="toc-preprocesado-1" class="nav-link" data-scroll-target="#preprocesado-1"><span class="toc-section-number">4.2.2.1</span>  Preprocesado</a></li>
  <li><a href="#nuestra-primera-red-neuronal" id="toc-nuestra-primera-red-neuronal" class="nav-link" data-scroll-target="#nuestra-primera-red-neuronal"><span class="toc-section-number">4.2.2.2</span>  Nuestra primera red neuronal</a></li>
  <li><a href="#actualizando-nuestra-red-neuronal-1" id="toc-actualizando-nuestra-red-neuronal-1" class="nav-link" data-scroll-target="#actualizando-nuestra-red-neuronal-1"><span class="toc-section-number">4.2.2.3</span>  Actualizando nuestra red neuronal</a></li>
  </ul></li>
  <li><a href="#water-potability-1" id="toc-water-potability-1" class="nav-link" data-scroll-target="#water-potability-1"><span class="toc-section-number">4.2.3</span>  Water potability</a>
  <ul class="collapse">
  <li><a href="#preprocesado-2" id="toc-preprocesado-2" class="nav-link" data-scroll-target="#preprocesado-2"><span class="toc-section-number">4.2.3.1</span>  Preprocesado</a></li>
  <li><a href="#nuestra-primera-red-neuronal-1" id="toc-nuestra-primera-red-neuronal-1" class="nav-link" data-scroll-target="#nuestra-primera-red-neuronal-1"><span class="toc-section-number">4.2.3.2</span>  Nuestra primera red neuronal</a></li>
  <li><a href="#actualizando-nuestra-red-neuronal-2" id="toc-actualizando-nuestra-red-neuronal-2" class="nav-link" data-scroll-target="#actualizando-nuestra-red-neuronal-2"><span class="toc-section-number">4.2.3.3</span>  Actualizando nuestra red neuronal</a></li>
  </ul></li>
  <li><a href="#breast-cancer-wisconsin-1" id="toc-breast-cancer-wisconsin-1" class="nav-link" data-scroll-target="#breast-cancer-wisconsin-1"><span class="toc-section-number">4.2.4</span>  Breast Cancer Wisconsin</a>
  <ul class="collapse">
  <li><a href="#preprocesado-3" id="toc-preprocesado-3" class="nav-link" data-scroll-target="#preprocesado-3"><span class="toc-section-number">4.2.4.1</span>  Preprocesado</a></li>
  <li><a href="#nuestra-primera-red-neuronal-2" id="toc-nuestra-primera-red-neuronal-2" class="nav-link" data-scroll-target="#nuestra-primera-red-neuronal-2"><span class="toc-section-number">4.2.4.2</span>  Nuestra primera red neuronal</a></li>
  <li><a href="#actualizando-nuestra-red-neuronal-3" id="toc-actualizando-nuestra-red-neuronal-3" class="nav-link" data-scroll-target="#actualizando-nuestra-red-neuronal-3"><span class="toc-section-number">4.2.4.3</span>  Actualizando nuestra red neuronal</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Aplicaciones Redes multicapa densas</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>En este tema nos enfrentamos a diferentes bancos de datos donde utilizaremos redes densas para problemas de clasificación y regresión, y pondremos en práctica todos los conceptos vistos en el tema anterior. En primer lugar presentamos los diferentes bancos de datos con los que trabajaremos a lo largo de este tema.</p>
<p>Cargamos las librerías necesarias para el trabajo en este tema:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Paquetes anteriores</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">library</span>(sjPlot)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="fu">library</span>(knitr) <span class="co"># para formatos de tablas</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="fu">library</span>(ggpubr)</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="fu">library</span>(cvms)</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="fu">theme_set</span>(<span class="fu">theme_sjplot2</span>())</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="fu">library</span>(mlr3verse)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="fu">library</span>(tensorflow)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="fu">library</span>(keras)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="conjuntos-de-datos" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="conjuntos-de-datos"><span class="header-section-number">4.1</span> Conjuntos de datos</h2>
<p>Vamos a trabajar con cuatro bancos de datos: dos enfocados en problemas de regresión y los otros dos en problemas de clasificación. En cada uno de ellos se establece el objetivo que se persigue, los inputs o predictoras consideradas, la presencia o no de observaciones anómalas, y el código necesario para la carga de datos.</p>
<section id="diabetes" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="diabetes"><span class="header-section-number">4.1.1</span> Diabetes</h3>
<p>En un estudio sobre la diabetes se obtuvieron diez variables basales, edad, sexo, índice de masa corporal, presión arterial media y seis mediciones de suero sanguíneo para 442 pacientes diabéticos, así como la respuesta de interés, una medida cuantitativa de la progresión de la enfermedad un año después de la entrada al estudio.</p>
<p><strong>Características del banco de datos</strong>:</p>
<ul>
<li>Target: <strong>Y</strong> (progresión de la enfermedad)</li>
<li>Valores perdidos: no</li>
<li>Número de registros: 442</li>
<li>Número de inputs: 10</li>
</ul>
<p><strong>Variables contenidas</strong>:</p>
<ul>
<li><strong>AGE</strong>: edad (en años)</li>
<li><strong>SEX</strong>: sexo (1 = Hombre, 2 = Mujer)</li>
<li><strong>BMI</strong>: índice de masa corporal</li>
<li><strong>BP</strong>: promedio de la presión sanguínea</li>
<li><strong>S1</strong>: colesterol sérico total</li>
<li><strong>S2</strong>: lipoproteínas de baja densidad</li>
<li><strong>S3</strong>: lipoproteínas de alta densidad</li>
<li><strong>S4</strong>: colesterol total</li>
<li><strong>S5</strong>: registro del nivel de triglicéridos en suero</li>
<li><strong>S6</strong>: nivel de azúcar en sangre</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>url <span class="ot">=</span> <span class="st">"https://raw.githubusercontent.com/ia4legos/MachineLearning/main/data/diabetes.tab.txt"</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>diabetes <span class="ot">=</span> <span class="fu">read_delim</span>(url, <span class="at">col_types =</span> <span class="st">"dfddddddddd"</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># Estructura de los datos</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="fu">str</span>(diabetes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>spc_tbl_ [442 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ AGE: num [1:442] 59 48 72 24 50 23 36 66 60 29 ...
 $ SEX: Factor w/ 2 levels "2","1": 1 2 1 2 2 2 1 1 1 2 ...
 $ BMI: num [1:442] 32.1 21.6 30.5 25.3 23 22.6 22 26.2 32.1 30 ...
 $ BP : num [1:442] 101 87 93 84 101 89 90 114 83 85 ...
 $ S1 : num [1:442] 157 183 156 198 192 139 160 255 179 180 ...
 $ S2 : num [1:442] 93.2 103.2 93.6 131.4 125.4 ...
 $ S3 : num [1:442] 38 70 41 40 52 61 50 56 42 43 ...
 $ S4 : num [1:442] 4 3 4 5 4 2 3 4.55 4 4 ...
 $ S5 : num [1:442] 4.86 3.89 4.67 4.89 4.29 ...
 $ S6 : num [1:442] 87 69 85 89 80 68 82 92 94 88 ...
 $ Y  : num [1:442] 151 75 141 206 135 97 138 63 110 310 ...
 - attr(*, "spec")=
  .. cols(
  ..   AGE = col_double(),
  ..   SEX = col_factor(levels = NULL, ordered = FALSE, include_na = FALSE),
  ..   BMI = col_double(),
  ..   BP = col_double(),
  ..   S1 = col_double(),
  ..   S2 = col_double(),
  ..   S3 = col_double(),
  ..   S4 = col_double(),
  ..   S5 = col_double(),
  ..   S6 = col_double(),
  ..   Y = col_double()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; </code></pre>
</div>
</div>
</section>
<section id="qsar" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="qsar"><span class="header-section-number">4.1.2</span> Qsar</h3>
<p>Este conjunto de datos se utilizó para desarrollar modelos QSAR de regresión cuantitativa para predecir la toxicidad acuática aguda hacia el pez Pimephales promelas (pececillo de cabeza plana) sobre un conjunto de 908 sustancias químicas. Como variable a predecir se consideraron los datos de la LC50, que es la concentración que provoca la muerte del 50% de sujetos sometidas a prueba durante 48 horas.</p>
<p><strong>Características del banco de datos</strong>:</p>
<ul>
<li>Target: <code>LC50</code></li>
<li>Valores perdidos: no</li>
</ul>
<p><strong>Variables contenidas</strong>:</p>
<ul>
<li><strong>TPSA</strong> (propiedades moleculares),</li>
<li><strong>SAacc</strong> (propiedades moleculares),</li>
<li><strong>H-050</strong> (fragmentos centrados en átomos),</li>
<li><strong>MLOGP</strong> (propiedades moleculares),</li>
<li><strong>RDCHI</strong> (índices de conectividad),</li>
<li><strong>GATS1p</strong> (autocorrelaciones 2D),</li>
<li><strong>nN</strong> (índices constitucionales),</li>
<li><strong>C-040</strong> (fragmentos centrados en átomos),</li>
<li><strong>LC50</strong></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>url <span class="ot">=</span> <span class="st">"https://raw.githubusercontent.com/jmsocuellamos/DatosBIOTEC/master/CaseStudies/Qsar/qsar_aquatic_toxicity.csv"</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>qsar <span class="ot">=</span> <span class="fu">read_csv</span>(url)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="water-potability" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3" class="anchored" data-anchor-id="water-potability"><span class="header-section-number">4.1.3</span> Water potability</h3>
<p>El agua potable es el derecho humano más básico y un factor importante para la salud. El conjunto de datos <code>Water potability</code>, tiene por objetivo estudiar la potabilidad del agua utilizando varias propiedades químicas debido a su importancia como cuestión de salud y desarrollo a nivel nacional, regional y local. En algunas regiones, se ha demostrado que las inversiones en abastecimiento de agua y saneamiento pueden producir un beneficio económico neto, ya que la reducción de los efectos adversos para la salud y los costes de la atención sanitaria superan los costes de las intervenciones.</p>
<p><strong>Características del banco de datos</strong>:</p>
<ul>
<li>Target: potability</li>
<li>Valores perdidos: sí (variables ph, Sulfate y Trihalomethanes)</li>
<li>Número de registros: 3276</li>
<li>Número de variables: 10</li>
</ul>
<p><strong>Variables contenidas</strong>:</p>
<ul>
<li><strong>pH</strong>: valor del pH.</li>
<li><strong>Hardness</strong>: dureza o capacidad del agua para precipitar el jabón causado por el calcio y el magnesio.</li>
<li><strong>Solids</strong>: sólidos disueltos totales (en partes por millón)</li>
<li><strong>Chloramines</strong>: cantidad de cloraminas (en partes por millón)</li>
<li><strong>Sulfate</strong>: cantidad de sulfatos disueltos (en mg/L)</li>
<li><strong>Conductivity</strong>: conductividad eléctrica del agua (en μS/cm)</li>
<li><strong>Organic_carbon</strong>: cantidad de carbono orgánico (en partes por millón)</li>
<li><strong>Trihalomethanes</strong>: cantidad de trihalometanos (en μg/L)</li>
<li><strong>Turbidity</strong>: medida de la propiedad de emisión de luz del agua en NTU.</li>
<li><strong>Potability</strong>: indica si el agua es segura para el consumo humano (1 = potable y 0 = no potable)</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>url <span class="ot">=</span> <span class="st">"https://raw.githubusercontent.com/ia4legos/MachineLearning/main/data/water_potability.csv"</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>waterpot <span class="ot">=</span> <span class="fu">read_csv</span>(url)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co"># Estructura de los datos</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">str</span>(waterpot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>spc_tbl_ [3,276 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ ph             : num [1:3276] NA 3.72 8.1 8.32 9.09 ...
 $ Hardness       : num [1:3276] 205 129 224 214 181 ...
 $ Solids         : num [1:3276] 20791 18630 19910 22018 17979 ...
 $ Chloramines    : num [1:3276] 7.3 6.64 9.28 8.06 6.55 ...
 $ Sulfate        : num [1:3276] 369 NA NA 357 310 ...
 $ Conductivity   : num [1:3276] 564 593 419 363 398 ...
 $ Organic_carbon : num [1:3276] 10.4 15.2 16.9 18.4 11.6 ...
 $ Trihalomethanes: num [1:3276] 87 56.3 66.4 100.3 32 ...
 $ Turbidity      : num [1:3276] 2.96 4.5 3.06 4.63 4.08 ...
 $ Potability     : num [1:3276] 0 0 0 0 0 0 0 0 0 0 ...
 - attr(*, "spec")=
  .. cols(
  ..   ph = col_double(),
  ..   Hardness = col_double(),
  ..   Solids = col_double(),
  ..   Chloramines = col_double(),
  ..   Sulfate = col_double(),
  ..   Conductivity = col_double(),
  ..   Organic_carbon = col_double(),
  ..   Trihalomethanes = col_double(),
  ..   Turbidity = col_double(),
  ..   Potability = col_double()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; </code></pre>
</div>
</div>
</section>
<section id="breast-cancer-wisconsin" class="level3" data-number="4.1.4">
<h3 data-number="4.1.4" class="anchored" data-anchor-id="breast-cancer-wisconsin"><span class="header-section-number">4.1.4</span> Breast Cancer Wisconsin</h3>
<p>En esta base de datos se recoge información sobre los cánceres de mama en la ciudad de Wisconsin. Las características de la base de datos se calculan a partir de una imagen digitalizada de un aspiración de aguja fina (FNA) de una masa mamaria. Describen las características de los núcleos celulares presentes en la imagen y el objetivo que se persigue es clasificar un tumor como benigno o maligno en función de las variables predictoras.</p>
<p><strong>Características del banco de datos</strong>:</p>
<ul>
<li>Variable respuesta: <code>diagnosis</code></li>
<li>Valores perdidos: no</li>
<li>Número de registros: 569</li>
<li>Número de variables: 32</li>
</ul>
<p><strong>Variables contenidas</strong>:</p>
<ul>
<li><strong>id</strong>: identificador.</li>
<li><strong>diagnosis</strong>: diagnóstico de tejidos mamarios (M = maligno, B = benigno)</li>
<li><strong>radius_mean</strong>: media de las distancias del centro a los puntos del perímetro.</li>
<li><strong>texture_mean</strong>: desviación estándar de los valores de la escala de grises.</li>
<li><strong>perimeter_mean</strong>:tamaño medio del tumor central.</li>
<li><strong>area_mean</strong>:</li>
<li><strong>smoothness_mean</strong>: media de variación local en longitudes de radio</li>
<li><strong>compactness_mean</strong>: (media de perímetro)^2 / área - 1,0</li>
<li><strong>concavity_mean</strong>: media de gravedad de las porciones cóncavas del contorno.</li>
<li><strong>concave points_mean</strong>: media para el número de porciones cóncavas del contorno.</li>
<li><strong>symmetry_mean</strong>:</li>
<li><strong>fractal_dimension_mean</strong>: media para “aproximación de la costa” - 1.</li>
<li><strong>radius_se</strong>: error estándar para la media de distancias desde el centro hasta los puntos en el perímetro.</li>
<li><strong>texture_se</strong>: error estándar para la desviación estándar de los valores de escala de grises.</li>
<li><strong>perimeter_se</strong>:</li>
<li><strong>area_se</strong>:</li>
<li><strong>smoothness_se</strong>: error estándar para la variación local en las longitudes del radio.</li>
<li><strong>compactness_se</strong>: (error estándar para perímetro)^2 / área - 1,0.</li>
<li><strong>concavity_se</strong>: error estándar para la gravedad de las partes cóncavas del contorno.</li>
<li><strong>concave points_se</strong>: error estándar para el número de porciones cóncavas del contorno.</li>
<li><strong>symmetry_se</strong>:</li>
<li><strong>fractal_dimension_se</strong>: error estándar para “aproximación de la costa” - 1.</li>
<li><strong>radius_worst</strong>: “peor” o mayor valor medio para la media de distancias desde el centro hasta los puntos del perímetro (en cm).</li>
<li><strong>texture_worst</strong>: “peor” o mayor valor medio para la desviación estándar de los valores de escala de grises.</li>
<li><strong>perimeter_worst</strong>:</li>
<li><strong>area_worst</strong>:</li>
<li><strong>smoothness_worst</strong>: “peor” o mayor valor medio para la variación local en longitudes de radio.</li>
<li><strong>compactness_worst</strong>: “peor” o mayor valor medio para el perímetro^2 / área - 1,0.</li>
<li><strong>concavity_worst</strong>: “peor” o mayor valor medio para la gravedad de las porciones cóncavas del contorno.</li>
<li><strong>concave points_worst</strong>: “peor” o mayor valor medio para el número de porciones cóncavas del contorno.</li>
<li><strong>symmetry_worst</strong>:</li>
<li><strong>fractal_dimension_worst</strong>: “peor” o mayor valor medio para “aproximación de la costa” - 1.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>url <span class="ot">=</span> <span class="st">"https://raw.githubusercontent.com/ia4legos/MachineLearning/main/data/cancer.csv"</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>breastcancer <span class="ot">=</span> <span class="fu">read_csv</span>(url, <span class="at">col_types =</span> <span class="st">"ccdddddddddddddddddddddddddddddd"</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co"># Estructura de los datos</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="fu">str</span>(breastcancer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>spc_tbl_ [569 × 32] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ id                     : chr [1:569] "842302" "842517" "84300903" "84348301" ...
 $ diagnosis              : chr [1:569] "M" "M" "M" "M" ...
 $ radius_mean            : num [1:569] 18 20.6 19.7 11.4 20.3 ...
 $ texture_mean           : num [1:569] 10.4 17.8 21.2 20.4 14.3 ...
 $ perimeter_mean         : num [1:569] 122.8 132.9 130 77.6 135.1 ...
 $ area_mean              : num [1:569] 1001 1326 1203 386 1297 ...
 $ smoothness_mean        : num [1:569] 0.1184 0.0847 0.1096 0.1425 0.1003 ...
 $ compactness_mean       : num [1:569] 0.2776 0.0786 0.1599 0.2839 0.1328 ...
 $ concavity_mean         : num [1:569] 0.3001 0.0869 0.1974 0.2414 0.198 ...
 $ concave_points_mean    : num [1:569] 0.1471 0.0702 0.1279 0.1052 0.1043 ...
 $ symmetry_mean          : num [1:569] 0.242 0.181 0.207 0.26 0.181 ...
 $ fractal_dimension_mean : num [1:569] 0.0787 0.0567 0.06 0.0974 0.0588 ...
 $ radius_se              : num [1:569] 1.095 0.543 0.746 0.496 0.757 ...
 $ texture_se             : num [1:569] 0.905 0.734 0.787 1.156 0.781 ...
 $ perimeter_se           : num [1:569] 8.59 3.4 4.58 3.44 5.44 ...
 $ area_se                : num [1:569] 153.4 74.1 94 27.2 94.4 ...
 $ smoothness_se          : num [1:569] 0.0064 0.00522 0.00615 0.00911 0.01149 ...
 $ compactness_se         : num [1:569] 0.049 0.0131 0.0401 0.0746 0.0246 ...
 $ concavity_se           : num [1:569] 0.0537 0.0186 0.0383 0.0566 0.0569 ...
 $ concave_points_se      : num [1:569] 0.0159 0.0134 0.0206 0.0187 0.0188 ...
 $ symmetry_se            : num [1:569] 0.03 0.0139 0.0225 0.0596 0.0176 ...
 $ fractal_dimension_se   : num [1:569] 0.00619 0.00353 0.00457 0.00921 0.00511 ...
 $ radius_worst           : num [1:569] 25.4 25 23.6 14.9 22.5 ...
 $ texture_worst          : num [1:569] 17.3 23.4 25.5 26.5 16.7 ...
 $ perimeter_worst        : num [1:569] 184.6 158.8 152.5 98.9 152.2 ...
 $ area_worst             : num [1:569] 2019 1956 1709 568 1575 ...
 $ smoothness_worst       : num [1:569] 0.162 0.124 0.144 0.21 0.137 ...
 $ compactness_worst      : num [1:569] 0.666 0.187 0.424 0.866 0.205 ...
 $ concavity_worst        : num [1:569] 0.712 0.242 0.45 0.687 0.4 ...
 $ concave_points_worst   : num [1:569] 0.265 0.186 0.243 0.258 0.163 ...
 $ symmetry_worst         : num [1:569] 0.46 0.275 0.361 0.664 0.236 ...
 $ fractal_dimension_worst: num [1:569] 0.1189 0.089 0.0876 0.173 0.0768 ...
 - attr(*, "spec")=
  .. cols(
  ..   id = col_character(),
  ..   diagnosis = col_character(),
  ..   radius_mean = col_double(),
  ..   texture_mean = col_double(),
  ..   perimeter_mean = col_double(),
  ..   area_mean = col_double(),
  ..   smoothness_mean = col_double(),
  ..   compactness_mean = col_double(),
  ..   concavity_mean = col_double(),
  ..   concave_points_mean = col_double(),
  ..   symmetry_mean = col_double(),
  ..   fractal_dimension_mean = col_double(),
  ..   radius_se = col_double(),
  ..   texture_se = col_double(),
  ..   perimeter_se = col_double(),
  ..   area_se = col_double(),
  ..   smoothness_se = col_double(),
  ..   compactness_se = col_double(),
  ..   concavity_se = col_double(),
  ..   concave_points_se = col_double(),
  ..   symmetry_se = col_double(),
  ..   fractal_dimension_se = col_double(),
  ..   radius_worst = col_double(),
  ..   texture_worst = col_double(),
  ..   perimeter_worst = col_double(),
  ..   area_worst = col_double(),
  ..   smoothness_worst = col_double(),
  ..   compactness_worst = col_double(),
  ..   concavity_worst = col_double(),
  ..   concave_points_worst = col_double(),
  ..   symmetry_worst = col_double(),
  ..   fractal_dimension_worst = col_double()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; </code></pre>
</div>
</div>
</section>
</section>
<section id="análisis-de-los-ejemplos" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="análisis-de-los-ejemplos"><span class="header-section-number">4.2</span> Análisis de los ejemplos</h2>
<p>Para el análisis de cada uno de los ejemplos seguimos siempre el mismo procedimiento:</p>
<ul>
<li>Preprocesado de los datos y preparación de los datos de muestra y entrenamiento.</li>
<li>Modelo basal de red neuronal.</li>
<li>Exploración de mejoras del modelo basal.</li>
</ul>
<section id="diabetes-1" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="diabetes-1"><span class="header-section-number">4.2.1</span> Diabetes</h3>
<p>Nos enfrentamos aquí a nuestro primer banco de datos cuya objetivo es predecir la progresión de la enfermedad (variable numérica) en función del conjunto de predictoras.</p>
<section id="preprocesado" class="level4" data-number="4.2.1.1">
<h4 data-number="4.2.1.1" class="anchored" data-anchor-id="preprocesado"><span class="header-section-number">4.2.1.1</span> Preprocesado</h4>
<p>En el preprocesado de los datos debemos identificar la presencia o no de valores faltantes para imputar los correspondientes valores, así como codificar los inputs o predictoras de tipo factor. Posteriormente establecemos las matrices de inputs y vector de outputs, y dividimos el conjunto de datos en muestra y validación, y estandarizamos los inputs numéricos.</p>
<p>En primer lugar establecemos la presencia o no de valores faltantes en nuestro conjunto de datos con el código siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># Valoramos a existencia de valores pérdidos</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="fu">apply</span>(<span class="fu">is.na</span>(diabetes),<span class="dv">2</span>,sum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>AGE SEX BMI  BP  S1  S2  S3  S4  S5  S6   Y 
  0   0   0   0   0   0   0   0   0   0   0 </code></pre>
</div>
</div>
<p>Generamos ahora la matriz de inputs y el vector de outputs, identificando los tipos de cada una de ellas y codificamos los inputs categóricos para convertirlos en entradas numéricas. En este caso solo tenemos la variable <code>SEX</code>. Como los valores de entrada son 1 (Hombres) y 2 (Mujeres) codificaremos 0-1 donde el 0 hace referencia a los hombres y 1 a las mujeres.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Output</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>y_diabetes <span class="ot">=</span> diabetes<span class="sc">$</span>Y</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co"># Matriz de inputs</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>X_diabetes <span class="ot">=</span> dplyr<span class="sc">::</span><span class="fu">select</span>(diabetes, <span class="sc">-</span><span class="fu">c</span>(<span class="st">"Y"</span>))</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co"># Tipo de input</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>tipos <span class="ot">=</span> <span class="fu">sapply</span>(X_diabetes,class)</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># Conjunto de numéricas</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>Xnum <span class="ot">=</span> X_diabetes[,<span class="fu">names</span>(X_diabetes)[tipos <span class="sc">==</span> <span class="st">"numeric"</span>]]</span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="do">########## Recodificación factor ########</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co"># Codificación 0-1</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>X_diabetes<span class="sc">$</span>SEX_cod <span class="ot">=</span> <span class="fu">as.numeric</span>(X_diabetes<span class="sc">$</span>SEX) <span class="sc">-</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Establecemos ahora la división en muestras de entrenamiento (80%) y validación (20%), y estandarizamos los inputs numéricos. Para ello seleccionamos la columnas correspondientes con la variable <code>tipos</code> que acabamos de definir.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="do">####### División de muestras #############</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co"># semilla para reproducibilidad</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co"># Proporción muestra de entrenamiento</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>np <span class="ot">=</span> <span class="fl">0.8</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co"># número de muestras</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>muestras <span class="ot">=</span> <span class="fu">nrow</span>(diabetes)</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co"># Índices de la muestra de entrenamiento para la selección</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>ids_train <span class="ot">=</span> <span class="fu">sample</span>(muestras, np<span class="sc">*</span>muestras)</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co"># Identificamos entrenamiento y validación matriz numéricas</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>xtrain <span class="ot">=</span> Xnum[ids_train,]</span>
<span id="cb12-12"><a href="#cb12-12"></a>xtest <span class="ot">=</span> Xnum[<span class="sc">-</span>ids_train,]</span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="do">######## Estandarización #################</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="co"># Medias</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>mean_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, mean)</span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="co"># Desviaciones típicas</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>sd_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, sd)</span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>xtrain_est <span class="ot">=</span> <span class="fu">scale</span>(xtrain, mean_train, sd_train)</span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>xtest_est <span class="ot">=</span> <span class="fu">scale</span>(xtest, mean_train, sd_train)</span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="co"># Muestras de entrenamiento y validación</span></span>
<span id="cb12-23"><a href="#cb12-23"></a>xtrain_diabetes <span class="ot">=</span> <span class="fu">cbind</span>(xtrain_est, X_diabetes<span class="sc">$</span>SEX_cod[ids_train])</span>
<span id="cb12-24"><a href="#cb12-24"></a>xtest_diabetes <span class="ot">=</span> <span class="fu">cbind</span>(xtest_est, X_diabetes<span class="sc">$</span>SEX_cod[<span class="sc">-</span>ids_train])</span>
<span id="cb12-25"><a href="#cb12-25"></a>ytrain_diabetes <span class="ot">=</span> y_diabetes[ids_train]</span>
<span id="cb12-26"><a href="#cb12-26"></a>ytest_diabetes <span class="ot">=</span> y_diabetes[<span class="sc">-</span>ids_train]</span>
<span id="cb12-27"><a href="#cb12-27"></a><span class="co"># Número de inputs</span></span>
<span id="cb12-28"><a href="#cb12-28"></a>inputs <span class="ot">=</span> <span class="fu">ncol</span>(xtrain_diabetes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una vez establecidas las muestras de entrenamiento y validación realizamos un pequeño análisis descriptivo para analizar el comportamiento de los inputs en cada conjunto. Tratamos de ver si la división establecida puede generar algún tipo de sesgo en los resultados de la red neuronal.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="do">## Variables numéricas</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="fu">data.frame</span>(<span class="st">"Media Entrenamiento"</span> <span class="ot">=</span> <span class="fu">apply</span>(xtrain_diabetes[,<span class="sc">-</span><span class="dv">10</span>], <span class="dv">2</span>, mean),</span>
<span id="cb13-3"><a href="#cb13-3"></a>           <span class="st">"Media Validación"</span> <span class="ot">=</span> <span class="fu">apply</span>(xtest_diabetes[,<span class="sc">-</span><span class="dv">10</span>], <span class="dv">2</span>, mean)     </span>
<span id="cb13-4"><a href="#cb13-4"></a>           )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    Media.Entrenamiento Media.Validación
AGE        1.355376e-16      0.066388850
BMI        3.049895e-16      0.082392072
BP        -1.013833e-16      0.004494473
S1        -1.368985e-16      0.151572062
S2         1.932122e-17      0.058142653
S3         2.710708e-16      0.139454280
S4         3.162031e-16      0.018667633
S5        -3.399504e-17      0.134118151
S6        -4.357467e-16     -0.034787479</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="do">## Variables factor</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="fu">data.frame</span>(<span class="st">"Entrenamiento"</span> <span class="ot">=</span> <span class="fu">table</span>(xtrain_diabetes[,<span class="dv">10</span>])<span class="sc">/</span><span class="fu">nrow</span>(xtrain_diabetes),</span>
<span id="cb15-3"><a href="#cb15-3"></a>           <span class="st">"Validación"</span> <span class="ot">=</span> <span class="fu">table</span>(xtest_diabetes[,<span class="dv">10</span>])<span class="sc">/</span><span class="fu">nrow</span>(xtest_diabetes))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Entrenamiento.Var1 Entrenamiento.Freq Validación.Var1 Validación.Freq
1                  0           0.470255               0       0.4606742
2                  1           0.529745               1       0.5393258</code></pre>
</div>
</div>
<p>A la vista de los resultados la muestra parece bastante equilibrada y podemos pasar a establecer nuestra primera red neuronal para esta tarea de regresión.</p>
</section>
<section id="nuestra-primera-rn" class="level4" data-number="4.2.1.2">
<h4 data-number="4.2.1.2" class="anchored" data-anchor-id="nuestra-primera-rn"><span class="header-section-number">4.2.1.2</span> Nuestra primera RN</h4>
<p>La mayor diferencia entre los modelos de redes estudiados en el tema anterior y este primer modelo es que la capa de salida sólo tiene una neurona dado que estamos en una tarea de regresión y no necesita función de activación. En cuanto al resto del modelo vamos a considerar dos capas ocultas con 16 neuronas respectivamente, y con función de activación <code>relu</code>.</p>
<p>Para el proceso de aprendizaje utilizamos el algoritmo <code>rmsprop</code> con pérdida <code>mse</code> y utilizando como métrica <code>mean_squared_logarithmic_error</code>, es decir el logaritmo del error cuadrático medio. Finalmente para el entrenamiento consideramos 200 epochs para asegurar convergencia (la muestra no es muy grande y el proceso es muy rápido), un <code>batch_size</code> de 24, y con un 30% para la validación en el proceso de entrenamiento. Se pueden consultar todas las funciones de pérdida y métricas de aprendizaje en los enlaces: <a href="https://keras.io/api/losses/">loss</a>, <a href="https://keras.io/api/metrics/">metrics</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb17-2"><a href="#cb17-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>mod1 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> <span class="fu">dim</span>(xtrain_diabetes)[[<span class="dv">2</span>]], <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb17-6"><a href="#cb17-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="fu">summary</span>(mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: "sequential"
________________________________________________________________________________
 Layer (type)                       Output Shape                    Param #     
================================================================================
 dense_2 (Dense)                    (None, 16)                      176         
 dense_1 (Dense)                    (None, 16)                      272         
 dense (Dense)                      (None, 1)                       17          
================================================================================
Total params: 465 (1.82 KB)
Trainable params: 465 (1.82 KB)
Non-trainable params: 0 (0.00 Byte)
________________________________________________________________________________</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>mod1 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a>)</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co"># Colocamos verbose=0 para no presentar todo el proceso iterativo  </span></span>
<span id="cb19-6"><a href="#cb19-6"></a>history_mod1 <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_diabetes, ytrain_diabetes, <span class="at">batch_size =</span> <span class="dv">24</span>, </span>
<span id="cb19-7"><a href="#cb19-7"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split=</span><span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Analizamos el proceso iterativo de convergencia de la red neuronal:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="fu">plot</span>(history_mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-011-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>El modelo parece mostrar un buen comportamiento tanto en la función de pérdida como en la métríca de evaluación. Ambas muestras se comportan de forma casi idéntica y tenemos convergencia desde la epoch 60 o 70. Parece razonable que un reajuste de la arquitectura de la red (menos neuronas o añadir alguna capa más) podría llevarnos a un modelo más eficiente. Evaluamos la métrica sobre la muestra de validación:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>mod1 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_diabetes, ytest_diabetes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/3 - 0s - loss: 3180.7302 - mean_squared_logarithmic_error: 0.1763 - 33ms/epoch - 11ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>                          loss mean_squared_logarithmic_error 
                    3180.73022                        0.17632 </code></pre>
</div>
</div>
<p>El valor de la métrica es 0.1773 que es relativamente pequeño. Para evaluar la capacidad predictiva del modelo obtenemos la predicción y comparamos los resultados con los valores observados:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># predicción de la evolución de la enfermedad</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>prediccion <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_diabetes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/3 - 0s - 79ms/epoch - 26ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">pred =</span> prediccion, <span class="at">ori =</span> ytest_diabetes)</span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="co"># gráfico</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(ori, prediccion)) <span class="sc">+</span> </span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span>  </span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="fu">geom_abline</span>(<span class="at">intercept =</span> <span class="dv">0</span>, <span class="at">slope =</span> <span class="dv">1</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-013-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>La linea azul de referencia indica el ajuste perfecto, de forma que el modelo propuesto proporciona una buena solución. Tomaremos este modelo como nuestro modelo basal sobre el que iremos añadiendo modificaciones con el objeto de conseguir un modelo de predicción más preciso sin caer en el problema del sobreajuste.</p>
</section>
<section id="actualizando-nuestra-red-neuronal" class="level4" data-number="4.2.1.3">
<h4 data-number="4.2.1.3" class="anchored" data-anchor-id="actualizando-nuestra-red-neuronal"><span class="header-section-number">4.2.1.3</span> Actualizando nuestra red neuronal</h4>
<p>En este punto proponemos diferentes modificaciones de la red anterior empezando por los parámetros que pretenden controlar el sobreajuste (early stopping y drop-out). En concreto, fijamos un drop out del 50% en cada capa intermedia.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb27-2"><a href="#cb27-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="co"># callback early stopping</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>)</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>mod1 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb27-7"><a href="#cb27-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> <span class="fu">dim</span>(xtrain_diabetes)[[<span class="dv">2</span>]], <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb27-8"><a href="#cb27-8"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb27-9"><a href="#cb27-9"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="fu">summary</span>(mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: "sequential_1"
________________________________________________________________________________
 Layer (type)                       Output Shape                    Param #     
================================================================================
 dense_5 (Dense)                    (None, 16)                      176         
 dense_4 (Dense)                    (None, 16)                      272         
 dense_3 (Dense)                    (None, 1)                       17          
================================================================================
Total params: 465 (1.82 KB)
Trainable params: 465 (1.82 KB)
Non-trainable params: 0 (0.00 Byte)
________________________________________________________________________________</code></pre>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>mod1 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>)</span>
<span id="cb29-3"><a href="#cb29-3"></a>)</span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="co"># Eliminamos verbose para ver donde se detiene el proceo iterativono presentar todo el proceso iterativo  </span></span>
<span id="cb29-6"><a href="#cb29-6"></a>history_mod1 <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_diabetes, ytrain_diabetes, <span class="at">batch_size =</span> <span class="dv">24</span>, <span class="at">epochs =</span> <span class="dv">200</span>, </span>
<span id="cb29-7"><a href="#cb29-7"></a>                            <span class="at">validation_split=</span><span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Representamos gráficamente el proceso iterativo para verificar si el modeo se ha detenido antes de alcanzar las 200 evaluaciones.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="fu">plot</span>(history_mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-015-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>Podemos ver como el modelo se detiene antes de alcanzar las 125 evaluaciones. Añadimos ahora las capas de dropout al 50% antes de evaluar la capacidad predictiva del modelo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb31-2"><a href="#cb31-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co"># callback early stopping</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>)</span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>mod2 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb31-7"><a href="#cb31-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> <span class="fu">dim</span>(xtrain_diabetes)[[<span class="dv">2</span>]], <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb31-8"><a href="#cb31-8"></a>  <span class="fu">layer_dropout</span>(<span class="fl">0.5</span>) <span class="sc">%&gt;%</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb31-10"><a href="#cb31-10"></a>  <span class="fu">layer_dropout</span>(<span class="fl">0.5</span>) <span class="sc">%&gt;%</span></span>
<span id="cb31-11"><a href="#cb31-11"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="fu">summary</span>(mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: "sequential_1"
________________________________________________________________________________
 Layer (type)                       Output Shape                    Param #     
================================================================================
 dense_5 (Dense)                    (None, 16)                      176         
 dense_4 (Dense)                    (None, 16)                      272         
 dense_3 (Dense)                    (None, 1)                       17          
================================================================================
Total params: 465 (1.82 KB)
Trainable params: 465 (1.82 KB)
Non-trainable params: 0 (0.00 Byte)
________________________________________________________________________________</code></pre>
</div>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>mod2 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>)</span>
<span id="cb33-3"><a href="#cb33-3"></a>)</span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="co"># Eliminamos verbose para ver donde se detiene el proceo iterativono presentar todo el proceso iterativo  </span></span>
<span id="cb33-6"><a href="#cb33-6"></a>history_mod2 <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_diabetes, ytrain_diabetes, <span class="at">batch_size =</span> <span class="dv">24</span>, <span class="at">epochs =</span> <span class="dv">200</span>, </span>
<span id="cb33-7"><a href="#cb33-7"></a>                            <span class="at">validation_split=</span><span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En primer lugar evaluamos ambos modelos sobre la muestra de validación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a>mod1 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_diabetes, ytest_diabetes, <span class="at">verbose =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/3 - 0s - loss: 3628.7610 - mean_squared_logarithmic_error: 0.1949 - 30ms/epoch - 10ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>                          loss mean_squared_logarithmic_error 
                  3628.7609863                      0.1949135 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a>mod2 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_diabetes, ytest_diabetes, <span class="at">verbose =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/3 - 0s - loss: 5484.3213 - mean_squared_logarithmic_error: 0.2841 - 29ms/epoch - 10ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>                          loss mean_squared_logarithmic_error 
                  5484.3212891                      0.2840641 </code></pre>
</div>
</div>
<p>Se puede ver que el modelo sin dropout proporcione mejores valores en las métricas de validación pero los resultados son bastante similares. Podemos analizar más su comportamiento con el gráfico siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>mse1 <span class="ot">=</span> history_mod1<span class="sc">$</span>metrics<span class="sc">$</span>val_loss</span>
<span id="cb40-2"><a href="#cb40-2"></a>mse2 <span class="ot">=</span> history_mod2<span class="sc">$</span>metrics<span class="sc">$</span>val_loss</span>
<span id="cb40-3"><a href="#cb40-3"></a>lmse1 <span class="ot">=</span> history_mod1<span class="sc">$</span>metrics<span class="sc">$</span>val_mean_squared_logarithmic_error</span>
<span id="cb40-4"><a href="#cb40-4"></a>lmse2 <span class="ot">=</span> history_mod2<span class="sc">$</span>metrics<span class="sc">$</span>val_mean_squared_logarithmic_error</span>
<span id="cb40-5"><a href="#cb40-5"></a></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="fu">plot</span>(mse1, <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">col =</span> <span class="dv">1</span>, <span class="at">lwd =</span> <span class="fl">1.5</span>, <span class="at">xlim=</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">200</span>), <span class="at">xlab=</span><span class="st">"Epoch"</span>, <span class="at">ylab=</span><span class="st">"Value"</span>, </span>
<span id="cb40-8"><a href="#cb40-8"></a>     <span class="at">main =</span><span class="st">"validation MSE"</span>)</span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="fu">lines</span>(mse2, <span class="at">col =</span><span class="dv">2</span>, <span class="at">lwd =</span> <span class="fl">1.5</span>)</span>
<span id="cb40-10"><a href="#cb40-10"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="st">"Sin Dropout"</span>, <span class="st">"50% Dropout"</span>), <span class="at">lty =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">col =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb40-11"><a href="#cb40-11"></a></span>
<span id="cb40-12"><a href="#cb40-12"></a><span class="fu">plot</span>(lmse1, <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">col =</span> <span class="dv">1</span>, <span class="at">lwd =</span> <span class="fl">1.5</span>, <span class="at">xlim=</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">200</span>), <span class="at">xlab=</span><span class="st">"Epoch"</span>, <span class="at">ylab=</span><span class="st">"Value"</span>, </span>
<span id="cb40-13"><a href="#cb40-13"></a>     <span class="at">main =</span><span class="st">"validation log(MSE)"</span>)</span>
<span id="cb40-14"><a href="#cb40-14"></a><span class="fu">lines</span>(lmse2, <span class="at">col =</span><span class="dv">2</span>, <span class="at">lwd =</span> <span class="fl">1.5</span>)</span>
<span id="cb40-15"><a href="#cb40-15"></a><span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="st">"Sin Dropout"</span>, <span class="st">"50% Dropout"</span>), <span class="at">lty =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="at">col =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-018-1.png" class="img-fluid" width="768"></p>
</div>
</div>
<p>Realmente ambas soluciones son bastante semejantes con lo que podríamos optar por cualquiera de ellas. Si queremos protegernos frente al problema de sobre estimación podemos optar por la opción con dropout que en términos de las métricas proporciona resultados casi idénticos. En este caso optamos por la opción sin dropout para seguir explorando posibilidades de la red y por que el ajuste del modelo es tan rápido que no nos hace falta saltar neuronas en las diferentes capas.</p>
<p>Pasamos ahora a estudiar el efecto que sobre el modelo tienen los cambios en el learning rate y el batch size. En concreto consideramos valores 0.0001, 0.001, 0.01, 0.1, y 1 para el learning rate, y 8, 16, 32 y 64 para el batch size. En primer lugar definimos la arquitectura del modelo en función del learning rate:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1"></a>build_model <span class="ot">=</span> <span class="cf">function</span>(lr, ninputs)</span>
<span id="cb41-2"><a href="#cb41-2"></a>{</span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="co"># Función para la definición del modelo (arquitectura y proceso de aprendizaje)</span></span>
<span id="cb41-4"><a href="#cb41-4"></a></span>
<span id="cb41-5"><a href="#cb41-5"></a>  <span class="co">#  Valores de entrada</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>  <span class="co">#   tasa: tasa de aprendizaje</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>  <span class="co">#   ninuts: número de inputs</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>  </span>
<span id="cb41-9"><a href="#cb41-9"></a>  <span class="co"># Valores de salida</span></span>
<span id="cb41-10"><a href="#cb41-10"></a>  <span class="co">#   modelo: modelo configurado</span></span>
<span id="cb41-11"><a href="#cb41-11"></a>  </span>
<span id="cb41-12"><a href="#cb41-12"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb41-13"><a href="#cb41-13"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb41-14"><a href="#cb41-14"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb41-15"><a href="#cb41-15"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb41-16"><a href="#cb41-16"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb41-17"><a href="#cb41-17"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb41-18"><a href="#cb41-18"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb41-19"><a href="#cb41-19"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb41-20"><a href="#cb41-20"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(<span class="at">learning_rate =</span> lr), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>)</span>
<span id="cb41-21"><a href="#cb41-21"></a>  )</span>
<span id="cb41-22"><a href="#cb41-22"></a>  <span class="co"># Devolvemos el modelo configurado</span></span>
<span id="cb41-23"><a href="#cb41-23"></a>  <span class="fu">return</span>(mod)</span>
<span id="cb41-24"><a href="#cb41-24"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora planteamos el bucle de evaluación del learning rate y batch size. En early stopping añadimos patience igual a 5 para estabilizar la solución:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="co"># Lista donde almacenamos la métrica de evaluación de cada modelo</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>comparativa <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb42-3"><a href="#cb42-3"></a>lr <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.0001</span>, <span class="fl">0.001</span>, <span class="fl">0.01</span>, <span class="fl">0.1</span>, <span class="dv">1</span>)</span>
<span id="cb42-4"><a href="#cb42-4"></a>bs <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">8</span>, <span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>)</span>
<span id="cb42-5"><a href="#cb42-5"></a></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="co"># Bucle de evaluación</span></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="cf">for</span> (i <span class="cf">in</span> lr)</span>
<span id="cb42-8"><a href="#cb42-8"></a>{</span>
<span id="cb42-9"><a href="#cb42-9"></a>  <span class="cf">for</span> (j <span class="cf">in</span> bs)</span>
<span id="cb42-10"><a href="#cb42-10"></a>  {</span>
<span id="cb42-11"><a href="#cb42-11"></a>    modelo <span class="ot">=</span> <span class="fu">build_model</span>(<span class="at">lr =</span> i, <span class="at">ninputs =</span> <span class="fu">dim</span>(xtrain_diabetes)[[<span class="dv">2</span>]])</span>
<span id="cb42-12"><a href="#cb42-12"></a>    <span class="co"># callback early stopping</span></span>
<span id="cb42-13"><a href="#cb42-13"></a>    early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>, <span class="at">patience =</span> <span class="dv">5</span>)</span>
<span id="cb42-14"><a href="#cb42-14"></a>    <span class="co"># Entrenamiento</span></span>
<span id="cb42-15"><a href="#cb42-15"></a>    history <span class="ot">=</span> modelo <span class="sc">%&gt;%</span>  <span class="fu">fit</span>(xtrain_diabetes, ytrain_diabetes, <span class="at">batch_size =</span> j, <span class="at">epochs =</span> <span class="dv">200</span>, </span>
<span id="cb42-16"><a href="#cb42-16"></a>                            <span class="at">validation_split=</span><span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))</span>
<span id="cb42-17"><a href="#cb42-17"></a>    <span class="co"># Evaluación</span></span>
<span id="cb42-18"><a href="#cb42-18"></a>    valor <span class="ot">=</span> (modelo <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_diabetes, ytest_diabetes, <span class="at">verbose =</span> <span class="dv">0</span>))[<span class="dv">2</span>]</span>
<span id="cb42-19"><a href="#cb42-19"></a>    comparativa <span class="ot">=</span> <span class="fu">rbind</span>(comparativa, <span class="fu">c</span>(i,j,valor))</span>
<span id="cb42-20"><a href="#cb42-20"></a>  }</span>
<span id="cb42-21"><a href="#cb42-21"></a>}</span>
<span id="cb42-22"><a href="#cb42-22"></a><span class="co"># Data Frame de resultados</span></span>
<span id="cb42-23"><a href="#cb42-23"></a><span class="fu">colnames</span>(comparativa) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"lr"</span>, <span class="st">"Bs"</span>, <span class="st">"logMSE"</span>)</span>
<span id="cb42-24"><a href="#cb42-24"></a><span class="co"># Mejor combinación</span></span>
<span id="cb42-25"><a href="#cb42-25"></a>valores <span class="ot">=</span> comparativa[<span class="fu">which.min</span>(comparativa[,<span class="dv">3</span>]),]</span>
<span id="cb42-26"><a href="#cb42-26"></a>valores</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       lr        Bs    logMSE 
0.1000000 8.0000000 0.1452594 </code></pre>
</div>
</div>
<p>Reajustamos el modelo óptimo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb44-2"><a href="#cb44-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb44-5"><a href="#cb44-5"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> <span class="fu">dim</span>(xtrain_diabetes)[[<span class="dv">2</span>]], <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb44-6"><a href="#cb44-6"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb44-7"><a href="#cb44-7"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb44-9"><a href="#cb44-9"></a>mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(<span class="at">learning_rate =</span> valores[<span class="dv">1</span>]), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="co"># callback early stopping</span></span>
<span id="cb44-11"><a href="#cb44-11"></a>early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>, <span class="at">patience =</span> <span class="dv">5</span>)</span>
<span id="cb44-12"><a href="#cb44-12"></a><span class="co"># Entrenamiento</span></span>
<span id="cb44-13"><a href="#cb44-13"></a>history <span class="ot">=</span> mod <span class="sc">%&gt;%</span>  <span class="fu">fit</span>(xtrain_diabetes, ytrain_diabetes, <span class="at">batch_size =</span> valores[<span class="dv">2</span>], <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split=</span><span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))</span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="fu">plot</span>(history)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-021-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>El modelo estabiliza la solución sobre la epoch 50. Por último representamos los valores predichos por el modelo frente a los valores observados:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># predicción de la evolución de la enfermedad</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>prediccion <span class="ot">=</span> mod <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_diabetes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3/3 - 0s - 57ms/epoch - 19ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">pred =</span> prediccion, <span class="at">ori =</span> ytest_diabetes)</span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="co"># gráfico</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(ori, prediccion)) <span class="sc">+</span> </span>
<span id="cb47-4"><a href="#cb47-4"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span>  </span>
<span id="cb47-5"><a href="#cb47-5"></a>  <span class="fu">geom_abline</span>(<span class="at">intercept =</span> <span class="dv">0</span>, <span class="at">slope =</span> <span class="dv">1</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-022-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>Aunque podríamos seguir haciendo pruebas en nuestra arquitectura de red vamos a tomar esta como definitiva y procedemos con el estudio de validación para valorar el cambio en los resultados cuando iteramos las muestras de entrenamiento y validación. A continuación vemos el algoritmo de validación cruzada con <span class="math inline">\(k=10\)</span> folds y estudiamos la métrica de validación del modelo.</p>
<p>En primer lugar definimos la función que nos permite evaluar el modelo de red establecido para una división de entrenamiento y test específica:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a>build_model <span class="ot">=</span> <span class="cf">function</span>(xtrain, ytrain, xtest, ytest)</span>
<span id="cb48-2"><a href="#cb48-2"></a>{  </span>
<span id="cb48-3"><a href="#cb48-3"></a>  <span class="co"># Función para evaluar una red neuronal en función la muestra de netrenamiento y división </span></span>
<span id="cb48-4"><a href="#cb48-4"></a>  </span>
<span id="cb48-5"><a href="#cb48-5"></a>  <span class="co"># Valores de entrada</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>  <span class="co">#   xtrain: inputs de entrenamiento</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>  <span class="co">#   ytrain: target de entrenamiento</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>  <span class="co">#   xtest: inputs de validación</span></span>
<span id="cb48-9"><a href="#cb48-9"></a>  <span class="co">#   ytest: target de validación</span></span>
<span id="cb48-10"><a href="#cb48-10"></a>  </span>
<span id="cb48-11"><a href="#cb48-11"></a>  <span class="co"># Resultado</span></span>
<span id="cb48-12"><a href="#cb48-12"></a>  <span class="co">#   La función devuelve la evaluación de la métrica de interés en las muestras de validación  </span></span>
<span id="cb48-13"><a href="#cb48-13"></a>   </span>
<span id="cb48-14"><a href="#cb48-14"></a>  <span class="co"># Cuerpo de la función</span></span>
<span id="cb48-15"><a href="#cb48-15"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb48-16"><a href="#cb48-16"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb48-17"><a href="#cb48-17"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb48-18"><a href="#cb48-18"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb48-19"><a href="#cb48-19"></a>      <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> <span class="fu">dim</span>(xtrain)[[<span class="dv">2</span>]], <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb48-20"><a href="#cb48-20"></a>      <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb48-21"><a href="#cb48-21"></a>      <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb48-22"><a href="#cb48-22"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb48-23"><a href="#cb48-23"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(<span class="at">learning_rate =</span> <span class="fl">0.01</span>), </span>
<span id="cb48-24"><a href="#cb48-24"></a>                  <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb48-25"><a href="#cb48-25"></a>  <span class="co"># callback early stopping</span></span>
<span id="cb48-26"><a href="#cb48-26"></a>  early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>, <span class="at">patience =</span> <span class="dv">5</span>)</span>
<span id="cb48-27"><a href="#cb48-27"></a>  <span class="co"># Entrenamiento</span></span>
<span id="cb48-28"><a href="#cb48-28"></a>  history <span class="ot">=</span> mod <span class="sc">%&gt;%</span>  <span class="fu">fit</span>(xtrain, ytrain, <span class="at">batch_size =</span> <span class="dv">64</span>, <span class="at">epochs =</span> <span class="dv">200</span>, </span>
<span id="cb48-29"><a href="#cb48-29"></a>                         <span class="at">validation_split =</span> <span class="fl">0.3</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks =</span> <span class="fu">list</span>(early_stop))</span>
<span id="cb48-30"><a href="#cb48-30"></a>  <span class="co"># Evaluación del modelo</span></span>
<span id="cb48-31"><a href="#cb48-31"></a>  valor <span class="ot">=</span> (mod <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest, ytest))[<span class="dv">2</span>]</span>
<span id="cb48-32"><a href="#cb48-32"></a>  <span class="fu">return</span>(valor)</span>
<span id="cb48-33"><a href="#cb48-33"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Procedemos ahora con el bucle de evaluación de cada uno de los folds considerados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="co"># vector donde almacenamos la métrica de cada modelo</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>metrica <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="co"># Seleccionamos variables numéricas</span></span>
<span id="cb49-4"><a href="#cb49-4"></a>Xnum <span class="ot">=</span> X_diabetes[,<span class="sc">-</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">11</span>)]</span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="co"># Seleccionamos variables categóricas</span></span>
<span id="cb49-6"><a href="#cb49-6"></a>Xcat <span class="ot">=</span> X_diabetes[,<span class="dv">11</span>]</span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="co"># Establecemos número de folds</span></span>
<span id="cb49-8"><a href="#cb49-8"></a>folds <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb49-9"><a href="#cb49-9"></a><span class="co"># Número de muestras</span></span>
<span id="cb49-10"><a href="#cb49-10"></a>n <span class="ot">=</span> <span class="fu">nrow</span>(diabetes)</span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="co"># Tamaño de cada fold</span></span>
<span id="cb49-12"><a href="#cb49-12"></a>nfolds <span class="ot">=</span> <span class="fu">floor</span>(n<span class="sc">/</span>folds)<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb49-13"><a href="#cb49-13"></a></span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="co"># Bucle pra cada fold</span></span>
<span id="cb49-15"><a href="#cb49-15"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>folds)</span>
<span id="cb49-16"><a href="#cb49-16"></a>{</span>
<span id="cb49-17"><a href="#cb49-17"></a>  <span class="co"># Índice para la muestra de test</span></span>
<span id="cb49-18"><a href="#cb49-18"></a>  test <span class="ot">=</span> (nfolds<span class="sc">*</span>(i<span class="dv">-1</span>) <span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">min</span>(n, (nfolds<span class="sc">*</span>i))</span>
<span id="cb49-19"><a href="#cb49-19"></a>  <span class="co"># Selección inicial de entrenamiento y test para variables numéricas</span></span>
<span id="cb49-20"><a href="#cb49-20"></a>  dfnum_train <span class="ot">=</span> Xnum[<span class="sc">-</span>test,]</span>
<span id="cb49-21"><a href="#cb49-21"></a>  dfnum_test <span class="ot">=</span> Xnum[test,]</span>
<span id="cb49-22"><a href="#cb49-22"></a>  <span class="do">###############################</span></span>
<span id="cb49-23"><a href="#cb49-23"></a>  <span class="co"># Estandarización de numéricas</span></span>
<span id="cb49-24"><a href="#cb49-24"></a>  <span class="do">###############################</span></span>
<span id="cb49-25"><a href="#cb49-25"></a>  <span class="co"># Medias</span></span>
<span id="cb49-26"><a href="#cb49-26"></a>  mean_train <span class="ot">=</span> <span class="fu">apply</span>(dfnum_train, <span class="dv">2</span>, mean)</span>
<span id="cb49-27"><a href="#cb49-27"></a>  <span class="co"># Desviaciones típicas</span></span>
<span id="cb49-28"><a href="#cb49-28"></a>  sd_train <span class="ot">=</span> <span class="fu">apply</span>(dfnum_train, <span class="dv">2</span>, sd)</span>
<span id="cb49-29"><a href="#cb49-29"></a>  <span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb49-30"><a href="#cb49-30"></a>  xtrain_est <span class="ot">=</span> <span class="fu">scale</span>(dfnum_train, mean_train, sd_train)</span>
<span id="cb49-31"><a href="#cb49-31"></a>  <span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb49-32"><a href="#cb49-32"></a>  xtest_est <span class="ot">=</span> <span class="fu">scale</span>(dfnum_test, mean_train, sd_train)</span>
<span id="cb49-33"><a href="#cb49-33"></a>  <span class="do">#####################################</span></span>
<span id="cb49-34"><a href="#cb49-34"></a>  <span class="co"># Matrices de entrenamiento y test</span></span>
<span id="cb49-35"><a href="#cb49-35"></a>  <span class="do">#####################################</span></span>
<span id="cb49-36"><a href="#cb49-36"></a>  xtrain <span class="ot">=</span> <span class="fu">cbind</span>(xtrain_est, X_diabetes<span class="sc">$</span>SEX_cod[<span class="sc">-</span>test])</span>
<span id="cb49-37"><a href="#cb49-37"></a>  xtest <span class="ot">=</span> <span class="fu">cbind</span>(xtest_est, X_diabetes<span class="sc">$</span>SEX_cod[test])</span>
<span id="cb49-38"><a href="#cb49-38"></a>  ytrain <span class="ot">=</span> y_diabetes[<span class="sc">-</span>test]</span>
<span id="cb49-39"><a href="#cb49-39"></a>  ytest <span class="ot">=</span> y_diabetes[test]</span>
<span id="cb49-40"><a href="#cb49-40"></a>  <span class="do">#####################################</span></span>
<span id="cb49-41"><a href="#cb49-41"></a>  <span class="co"># Evaluación del modelo</span></span>
<span id="cb49-42"><a href="#cb49-42"></a>  <span class="do">#####################################</span></span>
<span id="cb49-43"><a href="#cb49-43"></a>  <span class="fu">cat</span>(<span class="st">"Comienza el entrenamiento para el fold "</span>, i, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb49-44"><a href="#cb49-44"></a>  res <span class="ot">=</span> <span class="fu">build_model</span>(xtrain, ytrain, xtest, ytest)</span>
<span id="cb49-45"><a href="#cb49-45"></a>  metrica <span class="ot">=</span> <span class="fu">c</span>(metrica, res)</span>
<span id="cb49-46"><a href="#cb49-46"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Comienza el entrenamiento para el fold  1 
2/2 - 0s - loss: 3443.1267 - mean_squared_logarithmic_error: 0.1920 - 37ms/epoch - 19ms/step
Comienza el entrenamiento para el fold  2 
2/2 - 0s - loss: 2547.6919 - mean_squared_logarithmic_error: 0.2057 - 23ms/epoch - 12ms/step
Comienza el entrenamiento para el fold  3 
2/2 - 0s - loss: 3490.7598 - mean_squared_logarithmic_error: 0.1617 - 29ms/epoch - 14ms/step
Comienza el entrenamiento para el fold  4 
2/2 - 0s - loss: 2609.2722 - mean_squared_logarithmic_error: 0.1373 - 25ms/epoch - 12ms/step
Comienza el entrenamiento para el fold  5 
2/2 - 0s - loss: 3539.8403 - mean_squared_logarithmic_error: 0.1747 - 23ms/epoch - 12ms/step
Comienza el entrenamiento para el fold  6 
2/2 - 0s - loss: 2684.8792 - mean_squared_logarithmic_error: 0.1758 - 22ms/epoch - 11ms/step
Comienza el entrenamiento para el fold  7 
2/2 - 0s - loss: 3580.5659 - mean_squared_logarithmic_error: 0.1944 - 22ms/epoch - 11ms/step
Comienza el entrenamiento para el fold  8 
2/2 - 0s - loss: 2978.9531 - mean_squared_logarithmic_error: 0.1153 - 23ms/epoch - 11ms/step
Comienza el entrenamiento para el fold  9 
2/2 - 0s - loss: 4252.6426 - mean_squared_logarithmic_error: 0.2079 - 23ms/epoch - 12ms/step
Comienza el entrenamiento para el fold  10 
2/2 - 0s - loss: 1879.3577 - mean_squared_logarithmic_error: 0.1500 - 23ms/epoch - 11ms/step</code></pre>
</div>
</div>
<p>Ahora definimos una función que nos proporciona el descriptivo de las métricas</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a>imp_descrip <span class="ot">=</span> <span class="cf">function</span>(m)</span>
<span id="cb51-2"><a href="#cb51-2"></a>{</span>
<span id="cb51-3"><a href="#cb51-3"></a>  <span class="fu">cat</span>(<span class="st">"N            : "</span>, <span class="fu">length</span>(m),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-4"><a href="#cb51-4"></a>  <span class="fu">cat</span>(<span class="st">"Media        : "</span>, <span class="fu">round</span>(<span class="fu">mean</span>(m),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-5"><a href="#cb51-5"></a>  <span class="fu">cat</span>(<span class="st">"SD           : "</span>, <span class="fu">round</span>(<span class="fu">sd</span>(m),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-6"><a href="#cb51-6"></a>  <span class="fu">cat</span>(<span class="st">"Mínimo       : "</span>, <span class="fu">round</span>(<span class="fu">min</span>(m),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-7"><a href="#cb51-7"></a>  <span class="fu">cat</span>(<span class="st">"Percentil 25 : "</span>, <span class="fu">round</span>(<span class="fu">quantile</span>(m, <span class="fl">0.25</span>),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-8"><a href="#cb51-8"></a>  <span class="fu">cat</span>(<span class="st">"Percentil 75 : "</span>, <span class="fu">round</span>(<span class="fu">quantile</span>(m, <span class="fl">0.75</span>),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-9"><a href="#cb51-9"></a>  <span class="fu">cat</span>(<span class="st">"Máximo       : "</span>, <span class="fu">round</span>(<span class="fu">max</span>(m),<span class="dv">3</span>),<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb51-10"><a href="#cb51-10"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Veamos los resultados para el análisis de validación realizado:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="fu">imp_descrip</span>(metrica)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>N            :  10 
Media        :  0.171 
SD           :  0.03 
Mínimo       :  0.115 
Percentil 25 :  0.153 
Percentil 75 :  0.194 
Máximo       :  0.208 </code></pre>
</div>
</div>
<p>¿qué podemos decir sobre los resultados obtenidos?</p>
</section>
</section>
<section id="qsar-1" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="qsar-1"><span class="header-section-number">4.2.2</span> Qsar</h3>
<p>Nos enfrentamos aquí a un banco de datos cuya objetivo es predecir la lD50 en función del conjunto de predictoras de tipo numérico.</p>
<section id="preprocesado-1" class="level4" data-number="4.2.2.1">
<h4 data-number="4.2.2.1" class="anchored" data-anchor-id="preprocesado-1"><span class="header-section-number">4.2.2.1</span> Preprocesado</h4>
<p>En el preprocesado de los datos debemos identificar la presencia o no de valores faltantes, establecer la matriz de inputs y vector de outputs, dividir el conjunto de datos en muestra y validación, y estandarizar los inputs numéricos.</p>
<p>En primer lugar establecemos la presencia o no de valores faltantes en nuestro conjunto de datos con el código siguiente:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># Valoramos a existencia de valores pérdidos</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="fu">apply</span>(<span class="fu">is.na</span>(qsar),<span class="dv">2</span>,sum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  TPSA  SAacc  H-050  MLOGP  RDCHI GATS1p     nN  C-040   LC50 
     0      0      0      0      0      0      0      0      0 </code></pre>
</div>
</div>
<p>Dado que no hay valores ausentes seguimos con el resto de pasos del preprocesamiento. Obtenemos la matriz de inputs y outpit, dividimos la muestra y estandarizamos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="do">####### nombres variables #######</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>nombres <span class="ot">=</span> <span class="fu">names</span>(qsar)</span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="do">######## Matriz de inputs #########</span></span>
<span id="cb56-4"><a href="#cb56-4"></a>X_qsar <span class="ot">=</span> qsar[,nombres[nombres <span class="sc">!=</span> <span class="st">"LC50"</span>]]</span>
<span id="cb56-5"><a href="#cb56-5"></a><span class="do">######## Vector de output #########</span></span>
<span id="cb56-6"><a href="#cb56-6"></a>y_qsar <span class="ot">=</span> qsar<span class="sc">$</span>LC50</span>
<span id="cb56-7"><a href="#cb56-7"></a><span class="co"># número de muestras total</span></span>
<span id="cb56-8"><a href="#cb56-8"></a>muestras <span class="ot">=</span> <span class="fu">nrow</span>(qsar)</span>
<span id="cb56-9"><a href="#cb56-9"></a><span class="co"># semilla para reproducibilidad</span></span>
<span id="cb56-10"><a href="#cb56-10"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb56-11"><a href="#cb56-11"></a><span class="co"># Proporción tamaño de entrenamiento </span></span>
<span id="cb56-12"><a href="#cb56-12"></a>np <span class="ot">=</span> <span class="fl">0.8</span></span>
<span id="cb56-13"><a href="#cb56-13"></a><span class="co"># indices de la muestra de entrenamiento</span></span>
<span id="cb56-14"><a href="#cb56-14"></a>ids_train <span class="ot">=</span> <span class="fu">sample</span>(muestras, <span class="at">size =</span> np<span class="sc">*</span>muestras)</span>
<span id="cb56-15"><a href="#cb56-15"></a></span>
<span id="cb56-16"><a href="#cb56-16"></a><span class="do">####### División de muestras #############</span></span>
<span id="cb56-17"><a href="#cb56-17"></a><span class="co"># Matriz de inputs</span></span>
<span id="cb56-18"><a href="#cb56-18"></a>xtrain <span class="ot">=</span> X_qsar[ids_train,]</span>
<span id="cb56-19"><a href="#cb56-19"></a>xtest <span class="ot">=</span> X_qsar[<span class="sc">-</span>ids_train,]</span>
<span id="cb56-20"><a href="#cb56-20"></a></span>
<span id="cb56-21"><a href="#cb56-21"></a><span class="do">######## Estandarización #################</span></span>
<span id="cb56-22"><a href="#cb56-22"></a><span class="co"># Medias</span></span>
<span id="cb56-23"><a href="#cb56-23"></a>mean_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, mean)</span>
<span id="cb56-24"><a href="#cb56-24"></a><span class="co"># Desviaciones típicas</span></span>
<span id="cb56-25"><a href="#cb56-25"></a>sd_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, sd)</span>
<span id="cb56-26"><a href="#cb56-26"></a><span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb56-27"><a href="#cb56-27"></a>xtrain_qsar <span class="ot">=</span> <span class="fu">scale</span>(xtrain, mean_train, sd_train)</span>
<span id="cb56-28"><a href="#cb56-28"></a><span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb56-29"><a href="#cb56-29"></a>xtest_qsar <span class="ot">=</span> <span class="fu">scale</span>(xtest, mean_train, sd_train)</span>
<span id="cb56-30"><a href="#cb56-30"></a><span class="co"># Muestras de entrenamiento y validación para output</span></span>
<span id="cb56-31"><a href="#cb56-31"></a>ytrain_qsar <span class="ot">=</span> y_qsar[ids_train]</span>
<span id="cb56-32"><a href="#cb56-32"></a>ytest_qsar <span class="ot">=</span> y_qsar[<span class="sc">-</span>ids_train]</span>
<span id="cb56-33"><a href="#cb56-33"></a><span class="co"># Número de inputs</span></span>
<span id="cb56-34"><a href="#cb56-34"></a>ninputs <span class="ot">=</span> <span class="fu">ncol</span>(xtrain_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="nuestra-primera-red-neuronal" class="level4" data-number="4.2.2.2">
<h4 data-number="4.2.2.2" class="anchored" data-anchor-id="nuestra-primera-red-neuronal"><span class="header-section-number">4.2.2.2</span> Nuestra primera red neuronal</h4>
<p>Consideramos una arquitectura de red con dos capas ocultas con 16 neuronas respectivamente, y con función de activación <code>relu</code>. Para el proceso de aprendizaje utilizamos el algoritmo <code>rmsprop</code> con pérdida <code>mse</code> y utilizando como métrica <code>mean_squared_logarithmic_error</code>, es decir el logaritmo del error cuadrático medio. Finalmente para el entrenamiento consideramos 200 epochs para asegurar convergencia (la muestra no es muy grande y el proceso es muy rápido), un <code>batch_size</code> de 24, y con un 20% para la validación en el proceso de entrenamiento.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb57-2"><a href="#cb57-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>mod1 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb57-5"><a href="#cb57-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb57-6"><a href="#cb57-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb57-7"><a href="#cb57-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="fu">summary</span>(mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model: "sequential_34"
________________________________________________________________________________
 Layer (type)                       Output Shape                    Param #     
================================================================================
 dense_104 (Dense)                  (None, 16)                      144         
 dense_103 (Dense)                  (None, 16)                      272         
 dense_102 (Dense)                  (None, 1)                       17          
================================================================================
Total params: 433 (1.69 KB)
Trainable params: 433 (1.69 KB)
Non-trainable params: 0 (0.00 Byte)
________________________________________________________________________________</code></pre>
</div>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>mod1 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb59-3"><a href="#cb59-3"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="co"># Colocamos verbose=0 para no presentar todo el proceso iterativo  </span></span>
<span id="cb59-5"><a href="#cb59-5"></a>history_mod1 <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_qsar, ytrain_qsar, <span class="at">batch_size =</span> <span class="dv">24</span>, </span>
<span id="cb59-6"><a href="#cb59-6"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split=</span><span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Analizamos el proceso iterativo de convergencia de la red neuronal:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a><span class="fu">plot</span>(history_mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/Qsar-004-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>El proceso converge en pocas epochs con unos resultados muy buenos. Evaluamos los resultados en al muestra de test, construímos la predicción asociada con el modelo y la representamos con respecto al target observado.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># Evaluación muestra de test</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>eval <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_qsar, ytest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 1.2088 - mean_squared_logarithmic_error: 0.0583 - 31ms/epoch - 8ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a><span class="fu">cat</span>(<span class="st">"Evaluación del modelo en la muestra de test: "</span>, eval)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Evaluación del modelo en la muestra de test:  1.208754 0.05825111</code></pre>
</div>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="co"># predicción de la evolución de la enfermedad</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>prediccion <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - 59ms/epoch - 15ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">pred =</span> prediccion, <span class="at">ori =</span> ytest_qsar)</span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="co"># gráfico</span></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(ori, prediccion)) <span class="sc">+</span> </span>
<span id="cb67-4"><a href="#cb67-4"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span>  </span>
<span id="cb67-5"><a href="#cb67-5"></a>  <span class="fu">geom_abline</span>(<span class="at">intercept =</span> <span class="dv">0</span>, <span class="at">slope =</span> <span class="dv">1</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/Qsar-005-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>El gráfico de dispersión muestra el buen comportamiento de los valores predichos.</p>
</section>
<section id="actualizando-nuestra-red-neuronal-1" class="level4" data-number="4.2.2.3">
<h4 data-number="4.2.2.3" class="anchored" data-anchor-id="actualizando-nuestra-red-neuronal-1"><span class="header-section-number">4.2.2.3</span> Actualizando nuestra red neuronal</h4>
<p>Al no apreciarse problemas de sobreaprendizaje podríamos quedarnos con este modelo como modelo final. Sin embargo, para simplificar el modelo de red vamos a considerar algunas modificaciones. en primer lugar vamos a reducir el número de epochs a la mitad y comparamos los resultados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb68-2"><a href="#cb68-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb68-4"><a href="#cb68-4"></a>mod2 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb68-5"><a href="#cb68-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb68-6"><a href="#cb68-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb68-7"><a href="#cb68-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb68-8"><a href="#cb68-8"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb68-9"><a href="#cb68-9"></a>mod2 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb68-10"><a href="#cb68-10"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb68-11"><a href="#cb68-11"></a><span class="co"># Colocamos verbose=0 para no presentar todo el proceso iterativo  </span></span>
<span id="cb68-12"><a href="#cb68-12"></a>history_mod2 <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_qsar, ytrain_qsar, <span class="at">batch_size =</span> <span class="dv">24</span>, </span>
<span id="cb68-13"><a href="#cb68-13"></a>                            <span class="at">epochs =</span> <span class="dv">100</span>, <span class="at">validation_split=</span><span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb68-14"><a href="#cb68-14"></a><span class="co"># Evaluación muestra de test</span></span>
<span id="cb68-15"><a href="#cb68-15"></a>eval <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_qsar, ytest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 1.2551 - mean_squared_logarithmic_error: 0.0560 - 25ms/epoch - 6ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1"></a><span class="fu">cat</span>(<span class="st">"Evaluación del modelo en la muestra de test: "</span>, eval)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Evaluación del modelo en la muestra de test:  1.255135 0.05602086</code></pre>
</div>
</div>
<p>El valor de la métrica para la muestra de test 0.0566 que es inferior al de la red anterior que era 0.0592 mostrando que la reducción de epochs mejora incluos la solución del modelo anterior. Podemos intentar ahora simplificar la red considerando una única capa oculta.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb72-2"><a href="#cb72-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb72-3"><a href="#cb72-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb72-4"><a href="#cb72-4"></a>mod3 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb72-5"><a href="#cb72-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">16</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb72-6"><a href="#cb72-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb72-8"><a href="#cb72-8"></a>mod3 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb72-9"><a href="#cb72-9"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb72-10"><a href="#cb72-10"></a><span class="co"># Colocamos verbose=0 para no presentar todo el proceso iterativo  </span></span>
<span id="cb72-11"><a href="#cb72-11"></a>history_mod3 <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_qsar, ytrain_qsar, <span class="at">batch_size =</span> <span class="dv">24</span>, </span>
<span id="cb72-12"><a href="#cb72-12"></a>                            <span class="at">epochs =</span> <span class="dv">100</span>, <span class="at">validation_split=</span><span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb72-13"><a href="#cb72-13"></a><span class="co"># Evaluación muestra de test</span></span>
<span id="cb72-14"><a href="#cb72-14"></a>eval <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_qsar, ytest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 1.3601 - mean_squared_logarithmic_error: 0.0560 - 29ms/epoch - 7ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1"></a><span class="fu">cat</span>(<span class="st">"Evaluación del modelo en la muestra de test: "</span>, eval)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Evaluación del modelo en la muestra de test:  1.360115 0.05598298</code></pre>
</div>
</div>
<p>La métrica del modelo es inferior al anterior, de forma que trabajar con un modelo más sencillo produce mejores resultados. Veamos que ocurre si reducimos ahora el número de neuronas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb76-2"><a href="#cb76-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb76-4"><a href="#cb76-4"></a>mod4 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb76-5"><a href="#cb76-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">8</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb76-6"><a href="#cb76-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb76-7"><a href="#cb76-7"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb76-8"><a href="#cb76-8"></a>mod4 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'mse'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'mean_squared_logarithmic_error'</span>))</span>
<span id="cb76-9"><a href="#cb76-9"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb76-10"><a href="#cb76-10"></a><span class="co"># Colocamos verbose=0 para no presentar todo el proceso iterativo  </span></span>
<span id="cb76-11"><a href="#cb76-11"></a>history_mod4 <span class="ot">=</span> mod4 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_qsar, ytrain_qsar, <span class="at">batch_size =</span> <span class="dv">24</span>, </span>
<span id="cb76-12"><a href="#cb76-12"></a>                            <span class="at">epochs =</span> <span class="dv">100</span>, <span class="at">validation_split=</span><span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb76-13"><a href="#cb76-13"></a><span class="co"># Evaluación muestra de test</span></span>
<span id="cb76-14"><a href="#cb76-14"></a>eval <span class="ot">=</span> mod4 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_qsar, ytest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 1.5103 - mean_squared_logarithmic_error: 0.0639 - 30ms/epoch - 8ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1"></a><span class="fu">cat</span>(<span class="st">"Evaluación del modelo en la muestra de test: "</span>, eval)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Evaluación del modelo en la muestra de test:  1.510266 0.06386463</code></pre>
</div>
</div>
<p>En este caso la solución empeora con loq ue reducir el número de neuronas produce un modelo con peror poder de predicción. Otras opciones pasarían por seguir modificando las características de la red para ver si podemos reducir el valo de la métrica de evaluación. Obtenemos la predicción para el mejor modleo encontrado hasta ahora y repreentamos de nuevo frente a los valores observados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1"></a><span class="co"># Evaluación muestra de test</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>eval <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_qsar, ytest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 1.3601 - mean_squared_logarithmic_error: 0.0560 - 42ms/epoch - 10ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1"></a><span class="fu">cat</span>(<span class="st">"Evaluación del modelo en la muestra de test: "</span>, eval)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Evaluación del modelo en la muestra de test:  1.360115 0.05598298</code></pre>
</div>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1"></a><span class="co"># predicción de la evolución de la enfermedad</span></span>
<span id="cb84-2"><a href="#cb84-2"></a>prediccion <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_qsar)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - 55ms/epoch - 14ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">pred =</span> prediccion, <span class="at">ori =</span> ytest_qsar)</span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="co"># gráfico</span></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(ori, prediccion)) <span class="sc">+</span> </span>
<span id="cb86-4"><a href="#cb86-4"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span>  </span>
<span id="cb86-5"><a href="#cb86-5"></a>  <span class="fu">geom_abline</span>(<span class="at">intercept =</span> <span class="dv">0</span>, <span class="at">slope =</span> <span class="dv">1</span>, <span class="at">col =</span> <span class="st">"blue"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/Qsar-009-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>Como era de esperar la solución es muy similar a la presentada antes, ya que la mejora en la métrica de evalaución no es suficente apra producir una solución muy diferente.</p>
</section>
</section>
<section id="water-potability-1" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="water-potability-1"><span class="header-section-number">4.2.3</span> Water potability</h3>
<p>En este caso nos enfrentamos a un problema de clasificación binario (agua potable o no potable) con un conjunto de predictoras de tipo numérico donde tenemos valores ausentes en algunas de ellas.</p>
<section id="preprocesado-2" class="level4" data-number="4.2.3.1">
<h4 data-number="4.2.3.1" class="anchored" data-anchor-id="preprocesado-2"><span class="header-section-number">4.2.3.1</span> Preprocesado</h4>
<p>En el preprocesado de los datos debemos identificar la presencia o no de valores faltantes para imputar los correspondientes valores, establecer las matrices de inputs y vector de outputs, dividir el conjunto de datos en muestra y validación, y estandarizar los inputs numéricos.</p>
<p>En primer lugar valoramos la presencia de valores faltantes:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1"></a><span class="co"># Valoramos a existencia de valores perdidos</span></span>
<span id="cb87-2"><a href="#cb87-2"></a><span class="fu">apply</span>(<span class="fu">is.na</span>(waterpot),<span class="dv">2</span>,sum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             ph        Hardness          Solids     Chloramines         Sulfate 
            491               0               0               0             781 
   Conductivity  Organic_carbon Trihalomethanes       Turbidity      Potability 
              0               0             162               0               0 </code></pre>
</div>
</div>
<p>Dado que se detectan valores ausentes en tres de los inputs podemos optar por dos soluciones:</p>
<ul>
<li>Eliminar todas las muestras que contiene al menos un valor ausente, que en este caso no resulta razonable ya que el tamaño del banco de datos pasaría de 3276 a 2011.</li>
<li>Imputar los valores ausentes con un valor adecuado. En este optamos por imputar con la mediana del resto de valores de la variable de interés.</li>
</ul>
<p>Veamos como realizar el proceso de imputación de forma rápida y sencilla. Básicamente se trata de identificar las posiciones donde se encuentran los valores ausentes y sustituir dichos valores por la mediana de esa variable.</p>
<p>No se detectan valores ausentes por lo que podemos establecer la matriz global de inputs y vector completo de output:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1"></a><span class="co"># Proceso de imputación en cada variable</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>waterpot[<span class="fu">is.na</span>(waterpot<span class="sc">$</span>ph),<span class="st">"ph"</span>] <span class="ot">=</span> <span class="fu">median</span>(waterpot<span class="sc">$</span>ph, <span class="at">na.rm =</span> T)</span>
<span id="cb89-3"><a href="#cb89-3"></a>waterpot[<span class="fu">is.na</span>(waterpot<span class="sc">$</span>Sulfate),<span class="st">"Sulfate"</span>] <span class="ot">=</span> <span class="fu">median</span>(waterpot<span class="sc">$</span>Sulfate, <span class="at">na.rm =</span> T)</span>
<span id="cb89-4"><a href="#cb89-4"></a>waterpot[<span class="fu">is.na</span>(waterpot<span class="sc">$</span>Trihalomethanes),<span class="st">"Trihalomethanes"</span>] <span class="ot">=</span> <span class="fu">median</span>(waterpot<span class="sc">$</span>Trihalomethanes, <span class="at">na.rm =</span> T)</span>
<span id="cb89-5"><a href="#cb89-5"></a><span class="co"># Valoramos de nuevo la presencia de valores ausentes</span></span>
<span id="cb89-6"><a href="#cb89-6"></a><span class="fu">apply</span>(<span class="fu">is.na</span>(waterpot),<span class="dv">2</span>,sum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             ph        Hardness          Solids     Chloramines         Sulfate 
              0               0               0               0               0 
   Conductivity  Organic_carbon Trihalomethanes       Turbidity      Potability 
              0               0               0               0               0 </code></pre>
</div>
</div>
<p>Ahora podemos seguir con el preprocesado. En concreto dividimos en muestra de entrenamiento y validación, para proceder posteriormente con la estandarización. Sin embargo la división en este caso debe mantener el porcentaje de 0-1 de la respuesta en la muestra de entrenamiento para no introducir sesgos de selección y ajuste durante el entrenamiento, ya que los tamaños originales no están equilibrados. Creamos la matriz de inputs y vector de target en primer lugar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1"></a><span class="do">####### nombres variables #######</span></span>
<span id="cb91-2"><a href="#cb91-2"></a>nombres <span class="ot">=</span> <span class="fu">names</span>(waterpot)</span>
<span id="cb91-3"><a href="#cb91-3"></a><span class="do">######## Matriz de inputs #########</span></span>
<span id="cb91-4"><a href="#cb91-4"></a>X_waterpot <span class="ot">=</span> waterpot[,nombres[nombres <span class="sc">!=</span> <span class="st">"Potability"</span>]]</span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="do">######## Vector de output #########</span></span>
<span id="cb91-6"><a href="#cb91-6"></a>y_waterpot <span class="ot">=</span> waterpot<span class="sc">$</span>Potability</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para poder muestrear de acuerdo a los tamaños originales de la variable <code>Potability</code> creamos un vector de pesos asociado con la proporción inicial de cada nivel de la respuesta. Veamos como realizar este proceso:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1"></a><span class="co"># número de muestras total</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>muestras <span class="ot">=</span> <span class="fu">nrow</span>(waterpot)</span>
<span id="cb92-3"><a href="#cb92-3"></a><span class="co"># semilla para reproducibilidad</span></span>
<span id="cb92-4"><a href="#cb92-4"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb92-5"><a href="#cb92-5"></a></span>
<span id="cb92-6"><a href="#cb92-6"></a><span class="do">######### muestreo de índices de entrenamiento ######</span></span>
<span id="cb92-7"><a href="#cb92-7"></a><span class="co">#&nbsp;1. Obtenemos los pesos de cada categoría de la respuesta</span></span>
<span id="cb92-8"><a href="#cb92-8"></a>tabla <span class="ot">=</span> <span class="fu">table</span>(waterpot<span class="sc">$</span>Potability)</span>
<span id="cb92-9"><a href="#cb92-9"></a>prop <span class="ot">=</span> <span class="fu">as.vector</span>(tabla<span class="sc">/</span><span class="fu">sum</span>(tabla))</span>
<span id="cb92-10"><a href="#cb92-10"></a><span class="co"># 2. Generamos el vector de pesos asociado ca cada muestra</span></span>
<span id="cb92-11"><a href="#cb92-11"></a>pesos <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">nrow</span>(waterpot))</span>
<span id="cb92-12"><a href="#cb92-12"></a>pesos[waterpot<span class="sc">$</span>Potability <span class="sc">==</span> <span class="dv">0</span>] <span class="ot">=</span> prop[<span class="dv">1</span>]</span>
<span id="cb92-13"><a href="#cb92-13"></a>pesos[waterpot<span class="sc">$</span>Potability <span class="sc">==</span> <span class="dv">1</span>] <span class="ot">=</span> prop[<span class="dv">2</span>]</span>
<span id="cb92-14"><a href="#cb92-14"></a><span class="co"># 3. Proporción muestra de entrenamiento</span></span>
<span id="cb92-15"><a href="#cb92-15"></a>np <span class="ot">=</span> <span class="fl">0.8</span></span>
<span id="cb92-16"><a href="#cb92-16"></a><span class="co"># 4. Indices para la muestra de entrenamiento</span></span>
<span id="cb92-17"><a href="#cb92-17"></a>ids_train <span class="ot">=</span> <span class="fu">sample</span>(muestras, <span class="at">size =</span> np<span class="sc">*</span>muestras, <span class="at">prob =</span> pesos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En primer lugar verificamos si se mantienen las proporciones de reparto de cada clase en la muestra de entrenamiento:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1"></a><span class="co"># Reparto en la población original</span></span>
<span id="cb93-2"><a href="#cb93-2"></a>tabla <span class="ot">=</span> <span class="fu">table</span>(waterpot<span class="sc">$</span>Potability)</span>
<span id="cb93-3"><a href="#cb93-3"></a>prop <span class="ot">=</span> <span class="fu">as.vector</span>(tabla<span class="sc">/</span><span class="fu">sum</span>(tabla))</span>
<span id="cb93-4"><a href="#cb93-4"></a>prop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6098901 0.3901099</code></pre>
</div>
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1"></a><span class="co"># Reparto en la muestra de entrenamiento</span></span>
<span id="cb95-2"><a href="#cb95-2"></a>tabla <span class="ot">=</span> <span class="fu">table</span>(waterpot<span class="sc">$</span>Potability[ids_train])</span>
<span id="cb95-3"><a href="#cb95-3"></a>prop <span class="ot">=</span> <span class="fu">as.vector</span>(tabla<span class="sc">/</span><span class="fu">sum</span>(tabla))</span>
<span id="cb95-4"><a href="#cb95-4"></a>prop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6557252 0.3442748</code></pre>
</div>
</div>
<p>Podemos ver que los porcentajes son muy similares con lo que podemos proceder con la división de muestras de entrenamiento y validación</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1"></a><span class="do">####### División de muestras #############</span></span>
<span id="cb97-2"><a href="#cb97-2"></a></span>
<span id="cb97-3"><a href="#cb97-3"></a><span class="co"># Matriz de inputs</span></span>
<span id="cb97-4"><a href="#cb97-4"></a>xtrain <span class="ot">=</span> X_waterpot[ids_train,]</span>
<span id="cb97-5"><a href="#cb97-5"></a>xtest <span class="ot">=</span> X_waterpot[<span class="sc">-</span>ids_train,]</span>
<span id="cb97-6"><a href="#cb97-6"></a></span>
<span id="cb97-7"><a href="#cb97-7"></a><span class="do">######## Estandarización #################</span></span>
<span id="cb97-8"><a href="#cb97-8"></a><span class="co"># Medias</span></span>
<span id="cb97-9"><a href="#cb97-9"></a>mean_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, mean)</span>
<span id="cb97-10"><a href="#cb97-10"></a><span class="co"># Desviaciones típicas</span></span>
<span id="cb97-11"><a href="#cb97-11"></a>sd_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, sd)</span>
<span id="cb97-12"><a href="#cb97-12"></a><span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb97-13"><a href="#cb97-13"></a>xtrain_waterpot <span class="ot">=</span> <span class="fu">scale</span>(xtrain, mean_train, sd_train)</span>
<span id="cb97-14"><a href="#cb97-14"></a><span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb97-15"><a href="#cb97-15"></a>xtest_waterpot <span class="ot">=</span> <span class="fu">scale</span>(xtest, mean_train, sd_train)</span>
<span id="cb97-16"><a href="#cb97-16"></a><span class="co"># Muestras de entrenamiento y validación para output</span></span>
<span id="cb97-17"><a href="#cb97-17"></a>ytrain_waterpot <span class="ot">=</span> y_waterpot[ids_train]</span>
<span id="cb97-18"><a href="#cb97-18"></a>ytest_waterpot <span class="ot">=</span> y_waterpot[<span class="sc">-</span>ids_train]</span>
<span id="cb97-19"><a href="#cb97-19"></a><span class="co"># Número de inputs</span></span>
<span id="cb97-20"><a href="#cb97-20"></a>ninputs <span class="ot">=</span> <span class="fu">ncol</span>(xtrain_waterpot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Una vez preprocesados los datos vamos a establecer nuestra primera red neuronal.</p>
</section>
<section id="nuestra-primera-red-neuronal-1" class="level4" data-number="4.2.3.2">
<h4 data-number="4.2.3.2" class="anchored" data-anchor-id="nuestra-primera-red-neuronal-1"><span class="header-section-number">4.2.3.2</span> Nuestra primera red neuronal</h4>
<p>Tenemos un problema de clasificación con dos posibles resultados por lo que debemos adaptar la arquitectura de nuestra red a esta situación. En este caso consideramos dos capas ocultas con 16 neuronas y con función de activación <code>relu</code>, mientras que consideramos la activación <code>sigmoid</code> en la capa de salida. En el proceso de aprendizaje consideramos como función de perdida <code>binary_crossentropy</code> y algoritmo de optmización <code>sgd</code>. En cuanto a la métrica para validar la capacidad de clasificación del algoritmo podemos utilizar la habitual (<code>accuracy</code>) o alguna de las ue viene recogidas en este <a href="https://keras.io/api/metrics/classification_metrics/">enlace</a> para variables respuesta con dos categorías. A modo de prueba vamos a usar <code>AUC</code> que nos porporciona el área bajo la curva ROC. Recordemos que cuanto más cerca a 1 se encuentre este valor mejor será la clasificación.</p>
<p>Finalmente para el entrenamiento consideramos 200 epochs, un <code>batch_size</code> de 16, y con un 20% para la validación en el proceso de entrenamiento.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb98-2"><a href="#cb98-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb98-3"><a href="#cb98-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb98-4"><a href="#cb98-4"></a>mod1 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb98-5"><a href="#cb98-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb98-6"><a href="#cb98-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb98-7"><a href="#cb98-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb98-8"><a href="#cb98-8"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb98-9"><a href="#cb98-9"></a>mod1 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb98-10"><a href="#cb98-10"></a>)</span>
<span id="cb98-11"><a href="#cb98-11"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb98-12"><a href="#cb98-12"></a>history_mod1 <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb98-13"><a href="#cb98-13"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb98-14"><a href="#cb98-14"></a><span class="fu">plot</span>(history_mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-033-1.png" class="img-fluid" width="768"></p>
</div>
</div>
<p>El análisis del gráfico muestra que no hemos alcanzado convergencia y que se produce cierto efecto de sobre estimación con el modelo propuesto. Parece obvio que demos modificar la red propuesta apra conseguir resultados más estables. Realizamos el proceso de evaluación del modelo para tener un punto de partida de comparación con el resto de modelos que propondremos a continuación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1"></a><span class="co"># Evaluación de la capacidad clasificadora</span></span>
<span id="cb99-2"><a href="#cb99-2"></a><span class="fu">cat</span>(<span class="st">"Métricas para la muestra de test"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Métricas para la muestra de test</code></pre>
</div>
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1"></a>mod1 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_waterpot, ytest_waterpot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>21/21 - 0s - loss: 0.8077 - auc: 0.6553 - 43ms/epoch - 2ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>     loss       auc 
0.8076965 0.6552669 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1"></a><span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1"></a><span class="co"># probabilidades de clasificación de cada muestra </span></span>
<span id="cb105-2"><a href="#cb105-2"></a>prediccion <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_waterpot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>21/21 - 0s - 72ms/epoch - 3ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1"></a><span class="co"># predicción del modelo</span></span>
<span id="cb107-2"><a href="#cb107-2"></a>pr_modelo <span class="ot">=</span> <span class="fu">as.vector</span>(prediccion <span class="sc">%&gt;%</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>(<span class="fl">0.5</span>) <span class="sc">%&gt;%</span> <span class="fu">k_cast</span>(<span class="st">"int32"</span>))</span>
<span id="cb107-3"><a href="#cb107-3"></a></span>
<span id="cb107-4"><a href="#cb107-4"></a><span class="co"># Matriz de confusión</span></span>
<span id="cb107-5"><a href="#cb107-5"></a>cm <span class="ot">=</span> <span class="fu">confusion_matrix</span>(ytest_waterpot, pr_modelo)</span>
<span id="cb107-6"><a href="#cb107-6"></a><span class="co"># Gráfico</span></span>
<span id="cb107-7"><a href="#cb107-7"></a><span class="fu">plot_confusion_matrix</span>(cm<span class="sc">$</span><span class="st">`</span><span class="at">Confusion Matrix</span><span class="st">`</span>[[<span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-034-1.png" class="img-fluid" width="768"></p>
</div>
</div>
</section>
<section id="actualizando-nuestra-red-neuronal-2" class="level4" data-number="4.2.3.3">
<h4 data-number="4.2.3.3" class="anchored" data-anchor-id="actualizando-nuestra-red-neuronal-2"><span class="header-section-number">4.2.3.3</span> Actualizando nuestra red neuronal</h4>
<p>En primer lugar consideramos la solución más sencilla que consiste en reducir el número de capas ocultas. En concreto consideramos una sola con las mismas especificaciones que en el modelo anterior.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb108-2"><a href="#cb108-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb108-3"><a href="#cb108-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb108-4"><a href="#cb108-4"></a>mod2 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb108-5"><a href="#cb108-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb108-6"><a href="#cb108-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb108-7"><a href="#cb108-7"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb108-8"><a href="#cb108-8"></a>mod2 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb108-9"><a href="#cb108-9"></a>)</span>
<span id="cb108-10"><a href="#cb108-10"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb108-11"><a href="#cb108-11"></a>history_mod2 <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb108-12"><a href="#cb108-12"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Definimos ahora una función que nos permite comparar ambas soluciones:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1"></a>compara_history <span class="ot">=</span> <span class="cf">function</span>(m1, m2)</span>
<span id="cb109-2"><a href="#cb109-2"></a>{</span>
<span id="cb109-3"><a href="#cb109-3"></a>  <span class="co"># Función que nos permite compara las historys de dos arquitecturas de red.</span></span>
<span id="cb109-4"><a href="#cb109-4"></a>  <span class="co"># en concreto evaluamos la loss y el auc</span></span>
<span id="cb109-5"><a href="#cb109-5"></a>  </span>
<span id="cb109-6"><a href="#cb109-6"></a>  <span class="co"># Parámetros de entrada</span></span>
<span id="cb109-7"><a href="#cb109-7"></a>  <span class="co">#   m1: history del modelo 1</span></span>
<span id="cb109-8"><a href="#cb109-8"></a>  <span class="co">#   m2: history del modelo 2</span></span>
<span id="cb109-9"><a href="#cb109-9"></a>  </span>
<span id="cb109-10"><a href="#cb109-10"></a>  <span class="co"># Resultado</span></span>
<span id="cb109-11"><a href="#cb109-11"></a>  <span class="co">#   gráfico comparativo de loss y auc </span></span>
<span id="cb109-12"><a href="#cb109-12"></a>  </span>
<span id="cb109-13"><a href="#cb109-13"></a>  h1m <span class="ot">=</span> m1<span class="sc">$</span>metrics</span>
<span id="cb109-14"><a href="#cb109-14"></a>  h2m <span class="ot">=</span> m2<span class="sc">$</span>metrics</span>
<span id="cb109-15"><a href="#cb109-15"></a>  minimoloss <span class="ot">=</span> <span class="fu">min</span>(h1m<span class="sc">$</span>loss, h1m<span class="sc">$</span>val_loss, h2m<span class="sc">$</span>loss, h2m<span class="sc">$</span>val_loss)</span>
<span id="cb109-16"><a href="#cb109-16"></a>  maximoloss <span class="ot">=</span> <span class="fu">max</span>(h1m<span class="sc">$</span>loss, h1m<span class="sc">$</span>val_loss, h2m<span class="sc">$</span>loss, h2m<span class="sc">$</span>val_loss)</span>
<span id="cb109-17"><a href="#cb109-17"></a>  minimoauc <span class="ot">=</span> <span class="fu">min</span>(h1m<span class="sc">$</span>auc, h1m<span class="sc">$</span>val_auc, h2m<span class="sc">$</span>auc, h2m<span class="sc">$</span>val_auc)</span>
<span id="cb109-18"><a href="#cb109-18"></a>  maximoauc <span class="ot">=</span> <span class="fu">max</span>(h1m<span class="sc">$</span>auc, h1m<span class="sc">$</span>val_auc, h2m<span class="sc">$</span>auc, h2m<span class="sc">$</span>val_auc)</span>
<span id="cb109-19"><a href="#cb109-19"></a></span>
<span id="cb109-20"><a href="#cb109-20"></a>  <span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb109-21"><a href="#cb109-21"></a>  <span class="fu">plot</span>(h1m<span class="sc">$</span>loss, <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">xlab =</span> <span class="st">"Epoch"</span>, <span class="at">ylab =</span> <span class="st">"loss"</span>, </span>
<span id="cb109-22"><a href="#cb109-22"></a>     <span class="at">ylim =</span> <span class="fu">c</span>(minimoloss, maximoloss))</span>
<span id="cb109-23"><a href="#cb109-23"></a>  <span class="fu">lines</span>(h2m<span class="sc">$</span>loss, <span class="at">col =</span> <span class="dv">2</span>)</span>
<span id="cb109-24"><a href="#cb109-24"></a>  <span class="fu">lines</span>(h1m<span class="sc">$</span>val_loss, <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb109-25"><a href="#cb109-25"></a>  <span class="fu">lines</span>(h2m<span class="sc">$</span>val_loss, <span class="at">lty =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="dv">2</span>)</span>
<span id="cb109-26"><a href="#cb109-26"></a>  <span class="fu">legend</span>(<span class="st">"topright"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="st">"M1 loss"</span>, <span class="st">"M2 loss"</span>, <span class="st">"M1 val-loss"</span>, <span class="st">"M2 val-loss"</span>), </span>
<span id="cb109-27"><a href="#cb109-27"></a>       <span class="at">lty =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="fu">rep</span>(<span class="dv">2</span>,<span class="dv">2</span>)), <span class="at">col =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb109-28"><a href="#cb109-28"></a></span>
<span id="cb109-29"><a href="#cb109-29"></a>  <span class="fu">plot</span>(h1m<span class="sc">$</span>auc, <span class="at">type =</span> <span class="st">"l"</span>, <span class="at">xlab =</span> <span class="st">"Epoch"</span>, <span class="at">ylab =</span> <span class="st">"AUC"</span>, </span>
<span id="cb109-30"><a href="#cb109-30"></a>     <span class="at">ylim =</span> <span class="fu">c</span>(minimoauc, maximoauc))</span>
<span id="cb109-31"><a href="#cb109-31"></a>  <span class="fu">lines</span>(h2m<span class="sc">$</span>auc, <span class="at">col =</span> <span class="dv">2</span>)</span>
<span id="cb109-32"><a href="#cb109-32"></a>  <span class="fu">lines</span>(h1m<span class="sc">$</span>val_auc, <span class="at">lty =</span> <span class="dv">2</span>)</span>
<span id="cb109-33"><a href="#cb109-33"></a>  <span class="fu">lines</span>(h2m<span class="sc">$</span>val_auc, <span class="at">lty =</span> <span class="dv">2</span>, <span class="at">col =</span> <span class="dv">2</span>)</span>
<span id="cb109-34"><a href="#cb109-34"></a>  <span class="fu">legend</span>(<span class="st">"bottomright"</span>, <span class="at">legend=</span><span class="fu">c</span>(<span class="st">"M1 AUC"</span>, <span class="st">"M2 AUC"</span>, <span class="st">"M1 val-AUC"</span>, <span class="st">"M2 val-AUC"</span>), </span>
<span id="cb109-35"><a href="#cb109-35"></a>       <span class="at">lty =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="fu">rep</span>(<span class="dv">2</span>,<span class="dv">2</span>)), <span class="at">col =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb109-36"><a href="#cb109-36"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1"></a><span class="fu">compara_history</span>(history_mod1, history_mod2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-037-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>El segundo planteado parece mejorar algo el problema de sobreajuste, aunque no soluciona el problema del todo. Veamos que ocurre si reducimos el número de neuronas. En concreto vamos a pasar de 32 a 8.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb111-2"><a href="#cb111-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb111-3"><a href="#cb111-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb111-4"><a href="#cb111-4"></a>mod3 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb111-5"><a href="#cb111-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">8</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb111-6"><a href="#cb111-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb111-7"><a href="#cb111-7"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb111-8"><a href="#cb111-8"></a>mod3 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb111-9"><a href="#cb111-9"></a>)</span>
<span id="cb111-10"><a href="#cb111-10"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb111-11"><a href="#cb111-11"></a>history_mod3 <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb111-12"><a href="#cb111-12"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comparamos las soluciones de los dos últimos modelos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1"></a><span class="fu">compara_history</span>(history_mod2, history_mod3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-039-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>La solución es muy similar a la anterior por lo tanto para obtener mejores resultados utilizamos la solución con 32 neuronas. Antes de pasar valorar diferentes opciones sobre el proceso de optimización valoramos lo que ocurre si introducimos una capa de dropout del 20%.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb113-2"><a href="#cb113-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb113-3"><a href="#cb113-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb113-4"><a href="#cb113-4"></a>mod4 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb113-5"><a href="#cb113-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb113-6"><a href="#cb113-6"></a>  <span class="fu">layer_dropout</span>(<span class="fl">0.2</span>) <span class="sc">%&gt;%</span></span>
<span id="cb113-7"><a href="#cb113-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb113-8"><a href="#cb113-8"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb113-9"><a href="#cb113-9"></a>mod4 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb113-10"><a href="#cb113-10"></a>)</span>
<span id="cb113-11"><a href="#cb113-11"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb113-12"><a href="#cb113-12"></a>history_mod4 <span class="ot">=</span> mod4 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb113-13"><a href="#cb113-13"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comparamos las soluciones de ambos modelos</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1"></a><span class="fu">compara_history</span>(history_mod2, history_mod4)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-041-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>El modelo es mucho más estable con lo que vamos a pasar a introducir mejoras sobre el proceso de optimización. En primer lugar vamos a considerar diferentes algoritmos de aprendizaje y learning rate. En concreto consideramos los algoritmos <code>rmsprop</code> y <code>ADAM</code> con tasas de aprendizaje 0.0001, 0.001, 0.01, y 0.1. Definimos una función con la arquitectura del modelo para cada algortimo de optimización antes de introducir el bucle de evaluación de todas las tasas de aprendiaje.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1"></a>build_model_sgd <span class="ot">=</span> <span class="cf">function</span>(lr)</span>
<span id="cb115-2"><a href="#cb115-2"></a>{</span>
<span id="cb115-3"><a href="#cb115-3"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb115-4"><a href="#cb115-4"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb115-5"><a href="#cb115-5"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb115-6"><a href="#cb115-6"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb115-7"><a href="#cb115-7"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb115-8"><a href="#cb115-8"></a>    <span class="fu">layer_dropout</span>(<span class="fl">0.2</span>) <span class="sc">%&gt;%</span></span>
<span id="cb115-9"><a href="#cb115-9"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb115-10"><a href="#cb115-10"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb115-11"><a href="#cb115-11"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(<span class="at">learning_rate =</span> lr), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>))</span>
<span id="cb115-12"><a href="#cb115-12"></a>  <span class="co"># Entrenamiento de los modelos</span></span>
<span id="cb115-13"><a href="#cb115-13"></a>  h1 <span class="ot">=</span> mod <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb115-14"><a href="#cb115-14"></a>  <span class="co"># Evaluación</span></span>
<span id="cb115-15"><a href="#cb115-15"></a>  eval <span class="ot">=</span> (mod <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_waterpot, ytest_waterpot, <span class="at">verbose =</span> <span class="dv">2</span>))[<span class="dv">2</span>]</span>
<span id="cb115-16"><a href="#cb115-16"></a><span class="fu">return</span> (eval) </span>
<span id="cb115-17"><a href="#cb115-17"></a>}</span>
<span id="cb115-18"><a href="#cb115-18"></a></span>
<span id="cb115-19"><a href="#cb115-19"></a>build_model_rmsprop <span class="ot">=</span> <span class="cf">function</span>(lr)</span>
<span id="cb115-20"><a href="#cb115-20"></a>{</span>
<span id="cb115-21"><a href="#cb115-21"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb115-22"><a href="#cb115-22"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb115-23"><a href="#cb115-23"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb115-24"><a href="#cb115-24"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb115-25"><a href="#cb115-25"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb115-26"><a href="#cb115-26"></a>    <span class="fu">layer_dropout</span>(<span class="fl">0.2</span>) <span class="sc">%&gt;%</span></span>
<span id="cb115-27"><a href="#cb115-27"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb115-28"><a href="#cb115-28"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb115-29"><a href="#cb115-29"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_rmsprop</span>(<span class="at">learning_rate =</span> lr), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>))</span>
<span id="cb115-30"><a href="#cb115-30"></a>  <span class="co"># Entrenamiento de los modelos</span></span>
<span id="cb115-31"><a href="#cb115-31"></a>  h1 <span class="ot">=</span> mod <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb115-32"><a href="#cb115-32"></a>  <span class="co"># Evaluación</span></span>
<span id="cb115-33"><a href="#cb115-33"></a>  eval <span class="ot">=</span> (mod <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_waterpot, ytest_waterpot, <span class="at">verbose =</span> <span class="dv">2</span>))[<span class="dv">2</span>]</span>
<span id="cb115-34"><a href="#cb115-34"></a><span class="fu">return</span> (eval) </span>
<span id="cb115-35"><a href="#cb115-35"></a>}</span>
<span id="cb115-36"><a href="#cb115-36"></a></span>
<span id="cb115-37"><a href="#cb115-37"></a>build_model_adam <span class="ot">=</span> <span class="cf">function</span>(lr)</span>
<span id="cb115-38"><a href="#cb115-38"></a>{</span>
<span id="cb115-39"><a href="#cb115-39"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb115-40"><a href="#cb115-40"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb115-41"><a href="#cb115-41"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb115-42"><a href="#cb115-42"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb115-43"><a href="#cb115-43"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb115-44"><a href="#cb115-44"></a>    <span class="fu">layer_dropout</span>(<span class="fl">0.2</span>) <span class="sc">%&gt;%</span></span>
<span id="cb115-45"><a href="#cb115-45"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb115-46"><a href="#cb115-46"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb115-47"><a href="#cb115-47"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_adam</span>(<span class="at">learning_rate =</span> lr), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>))</span>
<span id="cb115-48"><a href="#cb115-48"></a>  <span class="co"># Entrenamiento de los modelos</span></span>
<span id="cb115-49"><a href="#cb115-49"></a>  h1 <span class="ot">=</span> mod <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_waterpot, ytrain_waterpot, <span class="at">batch_size =</span> <span class="dv">16</span>, <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb115-50"><a href="#cb115-50"></a>  <span class="co"># Evaluación</span></span>
<span id="cb115-51"><a href="#cb115-51"></a>  eval <span class="ot">=</span> (mod <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_waterpot, ytest_waterpot, <span class="at">verbose =</span> <span class="dv">2</span>))[<span class="dv">2</span>]</span>
<span id="cb115-52"><a href="#cb115-52"></a><span class="fu">return</span> (eval) </span>
<span id="cb115-53"><a href="#cb115-53"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Veamos ahora el bucle con todos los algoritmos y tasas de aprendizaje propuestas:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1"></a><span class="co"># evaluación AUC de cada modelo sobre la muestra de validación</span></span>
<span id="cb116-2"><a href="#cb116-2"></a>eval_auc_sgd <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb116-3"><a href="#cb116-3"></a>eval_auc_rmsprop <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb116-4"><a href="#cb116-4"></a>eval_auc_adam <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb116-5"><a href="#cb116-5"></a></span>
<span id="cb116-6"><a href="#cb116-6"></a>lr <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.0001</span>, <span class="fl">0.001</span>, <span class="fl">0.01</span>, <span class="fl">0.1</span>)</span>
<span id="cb116-7"><a href="#cb116-7"></a></span>
<span id="cb116-8"><a href="#cb116-8"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb116-9"><a href="#cb116-9"></a>{</span>
<span id="cb116-10"><a href="#cb116-10"></a>  <span class="co"># Evaluación</span></span>
<span id="cb116-11"><a href="#cb116-11"></a>  eval_auc_sgd[i] <span class="ot">=</span> <span class="fu">build_model_sgd</span>(lr[i])</span>
<span id="cb116-12"><a href="#cb116-12"></a>  eval_auc_rmsprop[i] <span class="ot">=</span> <span class="fu">build_model_rmsprop</span>(lr[i])</span>
<span id="cb116-13"><a href="#cb116-13"></a>  eval_auc_adam[i] <span class="ot">=</span> <span class="fu">build_model_adam</span>(lr[i])  </span>
<span id="cb116-14"><a href="#cb116-14"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>21/21 - 0s - loss: 0.8722 - auc: 0.4855 - 43ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7524 - auc: 0.6562 - 71ms/epoch - 3ms/step
21/21 - 0s - loss: 0.7484 - auc: 0.6583 - 42ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7930 - auc: 0.5560 - 42ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7528 - auc: 0.6611 - 43ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7541 - auc: 0.6570 - 49ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7479 - auc: 0.6688 - 42ms/epoch - 2ms/step
21/21 - 0s - loss: 0.9565 - auc: 0.6428 - 42ms/epoch - 2ms/step
21/21 - 0s - loss: 0.8481 - auc: 0.6634 - 44ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7656 - auc: 0.6605 - 42ms/epoch - 2ms/step
21/21 - 0s - loss: 0.9907 - auc: 0.5833 - 44ms/epoch - 2ms/step
21/21 - 0s - loss: 0.7707 - auc: 0.5000 - 43ms/epoch - 2ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1"></a>eval_auc_sgd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.4854673 0.5559508 0.6687547 0.6605243</code></pre>
</div>
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1"></a>eval_auc_rmsprop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6562500 0.6610752 0.6427669 0.5832589</code></pre>
</div>
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1"></a>eval_auc_adam</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6583444 0.6569719 0.6633929 0.5000000</code></pre>
</div>
</div>
<p>Los tres algoritmos proporcionan soluciones muy similares, siendo el valor de <span class="math inline">\(\lambda\)</span> igual a 0.01 el que parece funcionar mejor, aunque en cualquier caso la solución obtenida parece bastante mala.</p>
<p>En este caso dejamos para el lector el análisis de validación del modelo conseguido finalmente. Utilizar <code>k = 10</code> folds para dicho análisis.</p>
</section>
</section>
<section id="breast-cancer-wisconsin-1" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="breast-cancer-wisconsin-1"><span class="header-section-number">4.2.4</span> Breast Cancer Wisconsin</h3>
<p>Antes de comenzar con el preprocesado de los datos hya dos tareas que debemos realizar: eliminar la variable <code>id</code> que identifica las muestras y codificar como 0-1 el target de interés. En este caso codificamos como <code>M = 1</code> y estudiamos la proporción de cada clase para saber si el diseño esta equilibrado.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1"></a><span class="co">#  Eliminación id</span></span>
<span id="cb124-2"><a href="#cb124-2"></a>breastcancer <span class="ot">=</span> dplyr<span class="sc">::</span><span class="fu">select</span>(breastcancer, <span class="sc">-</span><span class="st">"id"</span>)</span>
<span id="cb124-3"><a href="#cb124-3"></a><span class="co"># Recodificación diagnosis</span></span>
<span id="cb124-4"><a href="#cb124-4"></a>breastcancer[<span class="st">"diagnosis"</span>] <span class="ot">=</span> <span class="dv">1</span><span class="sc">*</span>(breastcancer[<span class="st">"diagnosis"</span>] <span class="sc">==</span> <span class="st">"M"</span>)</span>
<span id="cb124-5"><a href="#cb124-5"></a><span class="co"># Tabla</span></span>
<span id="cb124-6"><a href="#cb124-6"></a>tabla <span class="ot">=</span> <span class="fu">table</span>(breastcancer[<span class="st">"diagnosis"</span>])</span>
<span id="cb124-7"><a href="#cb124-7"></a>prop <span class="ot">=</span> tabla<span class="sc">/</span><span class="fu">sum</span>(tabla)</span>
<span id="cb124-8"><a href="#cb124-8"></a>prop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>diagnosis
        0         1 
0.6274165 0.3725835 </code></pre>
</div>
</div>
<p>Claramente el diseño está desequilibrado y deberemos tener en cuenta este aspecto en la división de muestras de entrenamiento y validación como en el ejemplo anterior. En este caso no tenemos inputs de tipo factor por lo que no es necesario ningún tipo de codificación.</p>
<section id="preprocesado-3" class="level4" data-number="4.2.4.1">
<h4 data-number="4.2.4.1" class="anchored" data-anchor-id="preprocesado-3"><span class="header-section-number">4.2.4.1</span> Preprocesado</h4>
<p>En el preprocesado de los datos debemos identificar la presencia o no de valores faltantes para imputar los correspondientes valores, establecer las matrices de inputs y vector de outputs, dividir el conjunto de datos en muestra y validación, y estandarizar los inputs numéricos.</p>
<p>En primer lugar valoramos la presencia de valores faltantes:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1"></a><span class="co"># Valoramos a existencia de valores perdidos</span></span>
<span id="cb126-2"><a href="#cb126-2"></a><span class="fu">apply</span>(<span class="fu">is.na</span>(breastcancer),<span class="dv">2</span>,sum)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>              diagnosis             radius_mean            texture_mean 
                      0                       0                       0 
         perimeter_mean               area_mean         smoothness_mean 
                      0                       0                       0 
       compactness_mean          concavity_mean     concave_points_mean 
                      0                       0                       0 
          symmetry_mean  fractal_dimension_mean               radius_se 
                      0                       0                       0 
             texture_se            perimeter_se                 area_se 
                      0                       0                       0 
          smoothness_se          compactness_se            concavity_se 
                      0                       0                       0 
      concave_points_se             symmetry_se    fractal_dimension_se 
                      0                       0                       0 
           radius_worst           texture_worst         perimeter_worst 
                      0                       0                       0 
             area_worst        smoothness_worst       compactness_worst 
                      0                       0                       0 
        concavity_worst    concave_points_worst          symmetry_worst 
                      0                       0                       0 
fractal_dimension_worst 
                      0 </code></pre>
</div>
</div>
<p>No existen valores faltantes por lo que podemos proceder con la división de muestras y estandarización. En primer lugar identificamos la matriz de inputs y vector de output.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1"></a><span class="do">####### nombres variables #######</span></span>
<span id="cb128-2"><a href="#cb128-2"></a>nombres <span class="ot">=</span> <span class="fu">names</span>(breastcancer)</span>
<span id="cb128-3"><a href="#cb128-3"></a><span class="do">######## Matriz de inputs #########</span></span>
<span id="cb128-4"><a href="#cb128-4"></a>X_breastcancer <span class="ot">=</span> breastcancer[,nombres[nombres <span class="sc">!=</span> <span class="st">"diagnosis"</span>]]</span>
<span id="cb128-5"><a href="#cb128-5"></a><span class="do">######## Vector de output #########</span></span>
<span id="cb128-6"><a href="#cb128-6"></a>y_breastcancer <span class="ot">=</span> breastcancer<span class="sc">$</span>diagnosis</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Procedemos ahora con la estandarización:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1"></a><span class="co"># número de muestras total</span></span>
<span id="cb129-2"><a href="#cb129-2"></a>muestras <span class="ot">=</span> <span class="fu">nrow</span>(breastcancer)</span>
<span id="cb129-3"><a href="#cb129-3"></a><span class="co"># semilla para reproducibilidad</span></span>
<span id="cb129-4"><a href="#cb129-4"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb129-5"><a href="#cb129-5"></a></span>
<span id="cb129-6"><a href="#cb129-6"></a><span class="do">######### muestreo de índices de entrenamiento ######</span></span>
<span id="cb129-7"><a href="#cb129-7"></a><span class="co"># 1. Generamos el vector de pesos asociado ca cada muestra</span></span>
<span id="cb129-8"><a href="#cb129-8"></a>pesos <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">0</span>, muestras)</span>
<span id="cb129-9"><a href="#cb129-9"></a>pesos[breastcancer<span class="sc">$</span>diagnosis <span class="sc">==</span> <span class="dv">0</span>] <span class="ot">=</span> prop[<span class="dv">1</span>]</span>
<span id="cb129-10"><a href="#cb129-10"></a>pesos[breastcancer<span class="sc">$</span>diagnosis <span class="sc">==</span> <span class="dv">1</span>] <span class="ot">=</span> prop[<span class="dv">2</span>]</span>
<span id="cb129-11"><a href="#cb129-11"></a><span class="co"># 2. Proporción muestra de entrenamiento</span></span>
<span id="cb129-12"><a href="#cb129-12"></a>np <span class="ot">=</span> <span class="fl">0.8</span></span>
<span id="cb129-13"><a href="#cb129-13"></a><span class="co"># 3. Indices para la muestra de entrenamiento</span></span>
<span id="cb129-14"><a href="#cb129-14"></a>ids_train <span class="ot">=</span> <span class="fu">sample</span>(muestras, <span class="at">size =</span> np<span class="sc">*</span>muestras, <span class="at">prob =</span> pesos)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Verificamos si se mantienen las proporciones de reparto de cada clase en la muestra de entrenamiento:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1"></a><span class="co"># Reparto en la población original</span></span>
<span id="cb130-2"><a href="#cb130-2"></a>prop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>diagnosis
        0         1 
0.6274165 0.3725835 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1"></a><span class="co"># Reparto en la muestra de entrenamiento</span></span>
<span id="cb132-2"><a href="#cb132-2"></a>tabla <span class="ot">=</span> <span class="fu">table</span>(breastcancer<span class="sc">$</span>diagnosis[ids_train])</span>
<span id="cb132-3"><a href="#cb132-3"></a>prop <span class="ot">=</span> <span class="fu">as.vector</span>(tabla<span class="sc">/</span><span class="fu">sum</span>(tabla))</span>
<span id="cb132-4"><a href="#cb132-4"></a>prop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6901099 0.3098901</code></pre>
</div>
</div>
<p>Podemos ver que los porcentajes son muy similares con lo que podemos proceder con la división de muestras de entrenamiento y validación</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1"></a><span class="do">####### División de muestras #############</span></span>
<span id="cb134-2"><a href="#cb134-2"></a></span>
<span id="cb134-3"><a href="#cb134-3"></a><span class="co"># Matriz de inputs</span></span>
<span id="cb134-4"><a href="#cb134-4"></a>xtrain <span class="ot">=</span> X_breastcancer[ids_train,]</span>
<span id="cb134-5"><a href="#cb134-5"></a>xtest <span class="ot">=</span> X_breastcancer[<span class="sc">-</span>ids_train,]</span>
<span id="cb134-6"><a href="#cb134-6"></a></span>
<span id="cb134-7"><a href="#cb134-7"></a><span class="do">######## Estandarización #################</span></span>
<span id="cb134-8"><a href="#cb134-8"></a><span class="co"># Medias</span></span>
<span id="cb134-9"><a href="#cb134-9"></a>mean_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, mean)</span>
<span id="cb134-10"><a href="#cb134-10"></a><span class="co"># Desviaciones típicas</span></span>
<span id="cb134-11"><a href="#cb134-11"></a>sd_train <span class="ot">=</span> <span class="fu">apply</span>(xtrain, <span class="dv">2</span>, sd)</span>
<span id="cb134-12"><a href="#cb134-12"></a><span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb134-13"><a href="#cb134-13"></a>xtrain_breastcancer <span class="ot">=</span> <span class="fu">scale</span>(xtrain, mean_train, sd_train)</span>
<span id="cb134-14"><a href="#cb134-14"></a><span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb134-15"><a href="#cb134-15"></a>xtest_breastcancer <span class="ot">=</span> <span class="fu">scale</span>(xtest, mean_train, sd_train)</span>
<span id="cb134-16"><a href="#cb134-16"></a><span class="co"># Muestras de entrenamiento y validación para output</span></span>
<span id="cb134-17"><a href="#cb134-17"></a>ytrain_breastcancer <span class="ot">=</span> y_breastcancer[ids_train]</span>
<span id="cb134-18"><a href="#cb134-18"></a>ytest_breastcancer <span class="ot">=</span> y_breastcancer[<span class="sc">-</span>ids_train]</span>
<span id="cb134-19"><a href="#cb134-19"></a><span class="co"># Número de inputs</span></span>
<span id="cb134-20"><a href="#cb134-20"></a>ninputs <span class="ot">=</span> <span class="fu">ncol</span>(xtrain_breastcancer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="nuestra-primera-red-neuronal-2" class="level4" data-number="4.2.4.2">
<h4 data-number="4.2.4.2" class="anchored" data-anchor-id="nuestra-primera-red-neuronal-2"><span class="header-section-number">4.2.4.2</span> Nuestra primera red neuronal</h4>
<p>Tenemos un problema de clasificación con dos posibles resultados por lo que utilizaremos una arquitectura similar al del ejemplo anterior. Consideramos dos capas ocultas con 16 neuronas y con función de activación <code>relu</code>, mientras que consideramos la activación <code>sigmoid</code> en la capa de salida. En el proceso de aprendizaje consideramos como función de perdida <code>binary_crossentropy</code> y algoritmo de optmización <code>sgd</code>. En cuanto a la métrica para validar la capacidad de clasificación volvemos a utilizar <code>AUC</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb135-2"><a href="#cb135-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb135-3"><a href="#cb135-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb135-4"><a href="#cb135-4"></a>mod1 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb135-5"><a href="#cb135-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb135-6"><a href="#cb135-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb135-7"><a href="#cb135-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb135-8"><a href="#cb135-8"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb135-9"><a href="#cb135-9"></a>mod1 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb135-10"><a href="#cb135-10"></a>)</span>
<span id="cb135-11"><a href="#cb135-11"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb135-12"><a href="#cb135-12"></a>history_mod1 <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_breastcancer, ytrain_breastcancer, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb135-13"><a href="#cb135-13"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb135-14"><a href="#cb135-14"></a><span class="fu">plot</span>(history_mod1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-050-1.png" class="img-fluid" width="768"></p>
</div>
</div>
<p>El algoritmo converge rápidamente y además con unos resultados bastante buenos. Evaluamos lo resultados sobre la muestra de validación:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1"></a>mod1 <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest_breastcancer, ytest_breastcancer, <span class="at">verbose =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - loss: 0.0956 - auc: 0.9975 - 29ms/epoch - 7ms/step</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>      loss        auc 
0.09562495 0.99754339 </code></pre>
</div>
</div>
<p>El valor del AUC es prácticamente 1 indicando que el modelo nos proporciona una clasificación casi perfecta. Evaluamos la matriz de confusión asociada con el modelo planteado.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1"></a><span class="co"># probabilidades de clasificación de cada muestra </span></span>
<span id="cb139-2"><a href="#cb139-2"></a>prediccion <span class="ot">=</span> mod1 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_breastcancer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - 60ms/epoch - 15ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1"></a><span class="co"># predicción del modelo</span></span>
<span id="cb141-2"><a href="#cb141-2"></a>pr_modelo <span class="ot">=</span> <span class="fu">as.vector</span>(prediccion <span class="sc">%&gt;%</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>(<span class="fl">0.5</span>) <span class="sc">%&gt;%</span> <span class="fu">k_cast</span>(<span class="st">"int32"</span>))</span>
<span id="cb141-3"><a href="#cb141-3"></a></span>
<span id="cb141-4"><a href="#cb141-4"></a><span class="co"># Matriz de confusión</span></span>
<span id="cb141-5"><a href="#cb141-5"></a>cm <span class="ot">=</span> <span class="fu">confusion_matrix</span>(ytest_breastcancer, pr_modelo)</span>
<span id="cb141-6"><a href="#cb141-6"></a>cm<span class="sc">$</span><span class="st">`</span><span class="at">Balanced Accuracy</span><span class="st">`</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9788732</code></pre>
</div>
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb143-1"><a href="#cb143-1"></a><span class="co"># Gráfico</span></span>
<span id="cb143-2"><a href="#cb143-2"></a><span class="fu">plot_confusion_matrix</span>(cm<span class="sc">$</span><span class="st">`</span><span class="at">Confusion Matrix</span><span class="st">`</span>[[<span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-051-2-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>El modelo solo proporciona un 2.6% de errores de clasificación indicando como benignos muestras etiquetadas con tumores malignos. Para evitar posibles de sobre estimación y reducir la complejidad de la red vamos a probar diferentes configuraciones en el punto siguiente</p>
</section>
<section id="actualizando-nuestra-red-neuronal-3" class="level4" data-number="4.2.4.3">
<h4 data-number="4.2.4.3" class="anchored" data-anchor-id="actualizando-nuestra-red-neuronal-3"><span class="header-section-number">4.2.4.3</span> Actualizando nuestra red neuronal</h4>
<p>En primer lugar consideramos la solución más sencilla que consiste en reducir el número de capas ocultas. En concreto consideramos una sola con las mismas especificaciones que en el modelo anterior.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb144-2"><a href="#cb144-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb144-3"><a href="#cb144-3"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb144-4"><a href="#cb144-4"></a>mod2 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb144-5"><a href="#cb144-5"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb144-6"><a href="#cb144-6"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb144-7"><a href="#cb144-7"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb144-8"><a href="#cb144-8"></a>mod2 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb144-9"><a href="#cb144-9"></a>)</span>
<span id="cb144-10"><a href="#cb144-10"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb144-11"><a href="#cb144-11"></a>history_mod2 <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_breastcancer, ytrain_breastcancer, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb144-12"><a href="#cb144-12"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comparamos ambas soluciones</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb145-1"><a href="#cb145-1"></a><span class="fu">compara_history</span>(history_mod1, history_mod2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-053-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>El segundo modelo proporciona una perdida ligeramente superior pero los resultados para el AUC son muy similares. Añadimos early stopping sobre el número de epochs para el segundo modelo para ver su efecto sobre la solución final.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1"></a><span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb146-2"><a href="#cb146-2"></a>inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb146-3"><a href="#cb146-3"></a><span class="co"># callback early stopping</span></span>
<span id="cb146-4"><a href="#cb146-4"></a>early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>)</span>
<span id="cb146-5"><a href="#cb146-5"></a><span class="co"># Arquitectura de red</span></span>
<span id="cb146-6"><a href="#cb146-6"></a>mod3 <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb146-7"><a href="#cb146-7"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb146-8"><a href="#cb146-8"></a>  <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb146-9"><a href="#cb146-9"></a><span class="co"># Proceso de aprendizaje</span></span>
<span id="cb146-10"><a href="#cb146-10"></a>mod3 <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>)</span>
<span id="cb146-11"><a href="#cb146-11"></a>)</span>
<span id="cb146-12"><a href="#cb146-12"></a><span class="co"># Entrenamiento del modelo</span></span>
<span id="cb146-13"><a href="#cb146-13"></a>history_mod3 <span class="ot">=</span> mod3 <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain_breastcancer, ytrain_breastcancer, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb146-14"><a href="#cb146-14"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))</span>
<span id="cb146-15"><a href="#cb146-15"></a><span class="fu">plot</span>(history_mod3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-054-1.png" class="img-fluid" width="960"></p>
</div>
</div>
<p>El algoritmo no se detiene antes de llegar al límite de epochs establecidos. Estudiamos la clasificación obtenida con este modelo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1"></a><span class="co"># probabilidades de clasificación de cada muestra </span></span>
<span id="cb147-2"><a href="#cb147-2"></a>prediccion <span class="ot">=</span> mod2 <span class="sc">%&gt;%</span> <span class="fu">predict</span>(xtest_breastcancer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4/4 - 0s - 69ms/epoch - 17ms/step</code></pre>
</div>
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb149-1"><a href="#cb149-1"></a><span class="co"># predicción del modelo</span></span>
<span id="cb149-2"><a href="#cb149-2"></a>pr_modelo <span class="ot">=</span> <span class="fu">as.vector</span>(prediccion <span class="sc">%&gt;%</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>(<span class="fl">0.5</span>) <span class="sc">%&gt;%</span> <span class="fu">k_cast</span>(<span class="st">"int32"</span>))</span>
<span id="cb149-3"><a href="#cb149-3"></a><span class="co"># Matriz de confusión</span></span>
<span id="cb149-4"><a href="#cb149-4"></a>cm <span class="ot">=</span> <span class="fu">confusion_matrix</span>(ytest_breastcancer, pr_modelo)</span>
<span id="cb149-5"><a href="#cb149-5"></a>cm<span class="sc">$</span><span class="st">`</span><span class="at">Balanced Accuracy</span><span class="st">`</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.9788732</code></pre>
</div>
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1"></a><span class="co"># Gráfico</span></span>
<span id="cb151-2"><a href="#cb151-2"></a><span class="fu">plot_confusion_matrix</span>(cm<span class="sc">$</span><span class="st">`</span><span class="at">Confusion Matrix</span><span class="st">`</span>[[<span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="40_AplMD_files/figure-html/apprmd-055-1.png" class="img-fluid" width="576"></p>
</div>
</div>
<p>Este modelo parece bastante bueno produciendo solo un 2.6% de errores. Aunque podemos seguir explorando otras posibilidades de modelización, las mejoras que podmeos conseguir son bastante reducidas a nivel de décimas en el porcentaje de clasificación correcta. Procedemos con el análisis de validación cruzada con <span class="math inline">\(k=10\)</span> folds.</p>
<p>En primer lugar definimos la función que nos evalúa el modelo propuesto en función de la muestra de entrenamiento y validación.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1"></a>build_model <span class="ot">=</span> <span class="cf">function</span>(xtrain, ytrain, xtest, ytest)</span>
<span id="cb152-2"><a href="#cb152-2"></a>{</span>
<span id="cb152-3"><a href="#cb152-3"></a>  <span class="co"># A partir de las muestars de entrenamiento y test esta función proporciona la </span></span>
<span id="cb152-4"><a href="#cb152-4"></a>  <span class="co"># evalaución del modelo de red propuesto.</span></span>
<span id="cb152-5"><a href="#cb152-5"></a>  </span>
<span id="cb152-6"><a href="#cb152-6"></a>  <span class="co"># Fijamos semilla de los pesos iniciales para poder </span></span>
<span id="cb152-7"><a href="#cb152-7"></a>  inicializador <span class="ot">=</span> <span class="fu">initializer_glorot_normal</span>(<span class="at">seed =</span> <span class="dv">15</span>)</span>
<span id="cb152-8"><a href="#cb152-8"></a>  <span class="co"># callback early stopping</span></span>
<span id="cb152-9"><a href="#cb152-9"></a>  early_stop <span class="ot">=</span> <span class="fu">callback_early_stopping</span>(<span class="at">monitor =</span> <span class="st">'val_loss'</span>)</span>
<span id="cb152-10"><a href="#cb152-10"></a>  <span class="co"># Arquitectura de red</span></span>
<span id="cb152-11"><a href="#cb152-11"></a>  mod <span class="ot">=</span> <span class="fu">keras_model_sequential</span>() <span class="sc">%&gt;%</span>  </span>
<span id="cb152-12"><a href="#cb152-12"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">32</span>, <span class="at">activation =</span> <span class="st">'relu'</span>, <span class="at">input_shape =</span> ninputs, <span class="at">kernel_initializer =</span> inicializador) <span class="sc">%&gt;%</span> </span>
<span id="cb152-13"><a href="#cb152-13"></a>    <span class="fu">layer_dense</span>(<span class="at">units =</span> <span class="dv">1</span>, <span class="at">activation =</span> <span class="st">'sigmoid'</span>, <span class="at">kernel_initializer =</span> inicializador)</span>
<span id="cb152-14"><a href="#cb152-14"></a>  <span class="co"># Proceso de aprendizaje</span></span>
<span id="cb152-15"><a href="#cb152-15"></a>  mod <span class="sc">%&gt;%</span> <span class="fu">compile</span>(<span class="at">loss =</span> <span class="st">'binary_crossentropy'</span>, <span class="at">optimizer =</span> <span class="fu">optimizer_sgd</span>(), <span class="at">metrics =</span> <span class="fu">c</span>(<span class="st">'AUC'</span>))</span>
<span id="cb152-16"><a href="#cb152-16"></a>  <span class="co"># Entrenamiento del modelo</span></span>
<span id="cb152-17"><a href="#cb152-17"></a>  history_mod <span class="ot">=</span> mod <span class="sc">%&gt;%</span> <span class="fu">fit</span>(xtrain, ytrain, <span class="at">batch_size =</span> <span class="dv">16</span>, </span>
<span id="cb152-18"><a href="#cb152-18"></a>                            <span class="at">epochs =</span> <span class="dv">200</span>, <span class="at">validation_split =</span> <span class="fl">0.2</span>, <span class="at">verbose =</span> <span class="dv">0</span>, <span class="at">callbacks=</span><span class="fu">list</span>(early_stop))  </span>
<span id="cb152-19"><a href="#cb152-19"></a>  <span class="co"># Evaluación del modelo</span></span>
<span id="cb152-20"><a href="#cb152-20"></a>  eval <span class="ot">=</span> (mod <span class="sc">%&gt;%</span> tensorflow<span class="sc">::</span><span class="fu">evaluate</span>(xtest, ytest, <span class="at">verbose =</span> <span class="dv">2</span>))[<span class="dv">2</span>]</span>
<span id="cb152-21"><a href="#cb152-21"></a>  <span class="fu">return</span>(eval)</span>
<span id="cb152-22"><a href="#cb152-22"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Procedemos ahora con el bucle de evaluación de cada uno de los folds considerados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1"></a><span class="co"># vector donde almacenamos la métrica de cada modelo</span></span>
<span id="cb153-2"><a href="#cb153-2"></a>metrica <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb153-3"><a href="#cb153-3"></a><span class="co"># Establecemos número de folds</span></span>
<span id="cb153-4"><a href="#cb153-4"></a>folds <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb153-5"><a href="#cb153-5"></a><span class="co"># Número de muestras</span></span>
<span id="cb153-6"><a href="#cb153-6"></a>n <span class="ot">=</span> <span class="fu">nrow</span>(breastcancer)</span>
<span id="cb153-7"><a href="#cb153-7"></a><span class="co"># Tamaño de cada fold</span></span>
<span id="cb153-8"><a href="#cb153-8"></a>nfolds <span class="ot">=</span> <span class="fu">floor</span>(n<span class="sc">/</span>folds)<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb153-9"><a href="#cb153-9"></a></span>
<span id="cb153-10"><a href="#cb153-10"></a><span class="co"># Bucle pra cada fold</span></span>
<span id="cb153-11"><a href="#cb153-11"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>folds)</span>
<span id="cb153-12"><a href="#cb153-12"></a>{</span>
<span id="cb153-13"><a href="#cb153-13"></a>  <span class="co"># Índice para la muestra de test</span></span>
<span id="cb153-14"><a href="#cb153-14"></a>  test <span class="ot">=</span> (nfolds<span class="sc">*</span>(i<span class="dv">-1</span>) <span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">min</span>(n, (nfolds<span class="sc">*</span>i))</span>
<span id="cb153-15"><a href="#cb153-15"></a>  <span class="co"># Selección inicial de entrenamiento y test para variables numéricas</span></span>
<span id="cb153-16"><a href="#cb153-16"></a>  dfnum_train <span class="ot">=</span> X_breastcancer[<span class="sc">-</span>test,]</span>
<span id="cb153-17"><a href="#cb153-17"></a>  dfnum_test <span class="ot">=</span> X_breastcancer[test,]</span>
<span id="cb153-18"><a href="#cb153-18"></a>  <span class="do">###################################</span></span>
<span id="cb153-19"><a href="#cb153-19"></a>  <span class="co"># Estadísticos para estandarización</span></span>
<span id="cb153-20"><a href="#cb153-20"></a>  <span class="do">##################################</span></span>
<span id="cb153-21"><a href="#cb153-21"></a>  <span class="co"># Medias</span></span>
<span id="cb153-22"><a href="#cb153-22"></a>  mean_train <span class="ot">=</span> <span class="fu">apply</span>(dfnum_train, <span class="dv">2</span>, mean)</span>
<span id="cb153-23"><a href="#cb153-23"></a>  <span class="co"># Desviaciones típicas</span></span>
<span id="cb153-24"><a href="#cb153-24"></a>  sd_train <span class="ot">=</span> <span class="fu">apply</span>(dfnum_train, <span class="dv">2</span>, sd)</span>
<span id="cb153-25"><a href="#cb153-25"></a>  <span class="do">#####################################</span></span>
<span id="cb153-26"><a href="#cb153-26"></a>  <span class="co"># Matrices de entrenamiento y test</span></span>
<span id="cb153-27"><a href="#cb153-27"></a>  <span class="do">#####################################  </span></span>
<span id="cb153-28"><a href="#cb153-28"></a>  <span class="co"># Estandarizamos muestra de entrenamiento</span></span>
<span id="cb153-29"><a href="#cb153-29"></a>  xtrain <span class="ot">=</span> <span class="fu">scale</span>(dfnum_train, mean_train, sd_train)</span>
<span id="cb153-30"><a href="#cb153-30"></a>  <span class="co"># Estandarizamos muestra de validación</span></span>
<span id="cb153-31"><a href="#cb153-31"></a>  xtest <span class="ot">=</span> <span class="fu">scale</span>(dfnum_test, mean_train, sd_train)</span>
<span id="cb153-32"><a href="#cb153-32"></a>  ytrain <span class="ot">=</span> y_breastcancer[<span class="sc">-</span>test]</span>
<span id="cb153-33"><a href="#cb153-33"></a>  ytest <span class="ot">=</span> y_breastcancer[test]</span>
<span id="cb153-34"><a href="#cb153-34"></a>  <span class="do">#####################################</span></span>
<span id="cb153-35"><a href="#cb153-35"></a>  <span class="co"># Evaluación del modelo</span></span>
<span id="cb153-36"><a href="#cb153-36"></a>  <span class="do">#####################################</span></span>
<span id="cb153-37"><a href="#cb153-37"></a>  <span class="fu">cat</span>(<span class="st">"Comienza el entrenamiento para el fold "</span>, i, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb153-38"><a href="#cb153-38"></a>  res <span class="ot">=</span> <span class="fu">build_model</span>(xtrain, ytrain, xtest, ytest)</span>
<span id="cb153-39"><a href="#cb153-39"></a>  metrica <span class="ot">=</span> <span class="fu">c</span>(metrica, res)</span>
<span id="cb153-40"><a href="#cb153-40"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Comienza el entrenamiento para el fold  1 
2/2 - 0s - loss: 0.0964 - auc: 0.9980 - 26ms/epoch - 13ms/step
Comienza el entrenamiento para el fold  2 
2/2 - 0s - loss: 0.1030 - auc: 0.9909 - 26ms/epoch - 13ms/step
Comienza el entrenamiento para el fold  3 
2/2 - 0s - loss: 0.1144 - auc: 0.9907 - 28ms/epoch - 14ms/step
Comienza el entrenamiento para el fold  4 
2/2 - 0s - loss: 0.0872 - auc: 0.9988 - 28ms/epoch - 14ms/step
Comienza el entrenamiento para el fold  5 
2/2 - 0s - loss: 0.0690 - auc: 0.9963 - 32ms/epoch - 16ms/step
Comienza el entrenamiento para el fold  6 
2/2 - 0s - loss: 0.1360 - auc: 0.9509 - 25ms/epoch - 12ms/step
Comienza el entrenamiento para el fold  7 
2/2 - 0s - loss: 0.0477 - auc: 1.0000 - 25ms/epoch - 13ms/step
Comienza el entrenamiento para el fold  8 
2/2 - 0s - loss: 0.0828 - auc: 0.9983 - 25ms/epoch - 13ms/step
Comienza el entrenamiento para el fold  9 
2/2 - 0s - loss: 0.0707 - auc: 1.0000 - 25ms/epoch - 13ms/step
Comienza el entrenamiento para el fold  10 
2/2 - 0s - loss: 0.1238 - auc: 0.9973 - 27ms/epoch - 14ms/step</code></pre>
</div>
</div>
<p>Realizamos el análisis descriptivo de la métrica evaluada.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1"></a><span class="fu">imp_descrip</span>(metrica)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>N            :  10 
Media        :  0.992 
SD           :  0.015 
Mínimo       :  0.951 
Percentil 25 :  0.992 
Percentil 75 :  0.999 
Máximo       :  1 </code></pre>
</div>
</div>
<p>EL valor medio del AUC para los 10 folds se sitúa en el 0.99 con una desviación típica de 0.016. Hay mucha precisión y los valores indican que el modelo clasifica casi de forma perfecta. El modelo propuesto nos puede servir para identificar el tipo de tumor de cáncer de mama en función de los inputs considerados.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./30_RMDDL.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Redes multicapa densas con Keras</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./50_ConvNN.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Redes convolucionales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">Copyright 2023, IA4LEGOS. Universidad Miguel Hernández de Elche</div>   
  </div>
</footer>



</body></html>